<!DOCTYPE html>
<html lang="ko">
<head>
  <meta name="description" content="코딩은 모험이다! 뉴프로 커뮤니티에서 아이디어를 나누고, 즐거운 코드 토크를 펼쳐보세요!" />
  <meta name="keywords" content="코딩, 커뮤니티, 프로그래밍, 개발자, 뉴프로" />
  <meta name="author" content="프로그래밍 갤러리 위원회" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2a4065">
  <meta property="og:title" content="뉴프로 커뮤니티" />
  <meta property="og:description" content="코딩은 모험이다! 뉴프로 커뮤니티에서 아이디어를 나누고, 즐거운 코드 토크를 펼쳐보세요!" />
  <title>뉴프로 커뮤니티</title>

  <!-- Google Font (Jua) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link 
    href="https://fonts.googleapis.com/css2?family=Jua&display=swap"
    rel="stylesheet"
  />
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />

  <!-- Toast UI Editor: CSS/JS, 코드블록 하이라이트 플러그인 -->
  <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
  <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
  <link rel="stylesheet" href="https://uicdn.toast.com/editor-plugin-code-syntax-highlight/latest/toastui-editor-plugin-code-syntax-highlight.min.css" />
  <script src="https://uicdn.toast.com/editor-plugin-code-syntax-highlight/latest/toastui-editor-plugin-code-syntax-highlight.min.js"></script>

  <!-- DOMPurify -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.3/purify.min.js" integrity="sha512-Ll+TuDvrWDNNRnFFIM8dOiw7Go7dsHyxRp4RutiIFW/wm3DgDmCnRZow6AqbXnCbpWu93yM1O34q+4ggzGeXVA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <style>
    /* 기본 배경 및 글꼴 등 */
    body {
      background: linear-gradient(135deg, #1f2945, #2a4065);
      min-height: 100vh;
      color: #fff;
      margin: 0;
      padding: 0;
    }
    .navbar {
      background: rgba(10, 10, 20, 0.7) !important;
    }
    .navbar-brand {
      font-family: 'Jua', sans-serif;
      font-size: 1.8rem;
    }
    .hero-section {
      text-align: center;
      padding: 3rem 1rem;
      background: transparent;
    }
    .hero-title {
      font-size: 3rem;
      font-weight: bold;
      margin-bottom: 1rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      color: #fff;
      font-family: 'Jua', sans-serif;
    }
    .hero-subtitle {
      font-size: 1.25rem;
      opacity: 0.9;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
      color: #d5d9e0;
      font-family: 'Jua', sans-serif;
    }
    .glass-card {
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(8px);
      border-radius: 1rem;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      color: #000;
    }
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
    }
    .toast.dark-bg {
      background-color: rgba(0,0,0,0.8);
      color: #fff;
    }
    .toast.dark-bg .toast-header {
      background-color: transparent;
      color: #fff;
      border-bottom: 1px solid #666;
    }
    .toast.dark-bg .btn-close {
      filter: invert(1);
    }
    .d-none {
      display: none !important;
    }
    .modal-content {
      background-color: #fff !important;
      color: #000 !important;
    }
    .comment-item {
      background-color: #f8f9fa;
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      margin-bottom: 0.5rem;
      color: #000;
    }
    .post-subtitle {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    .auth-loading {
      animation: spin 1.0s linear infinite;
    }
    #postList img {
      max-width: 100%;
      height: auto;
    }
    .shining-btn {
      position: relative;
      overflow: hidden;
      background-color: #ff69b4;
      color: #fff;
      border: none;
      border-radius: 5px;
      box-shadow: 0 0 8px rgba(255,105,180, 0.6);
      font-weight: bold;
      cursor: pointer;
    }
    .shining-btn::before {
      content: "";
      position: absolute;
      top: -100%;
      left: -100%;
      width: 200%;
      height: 200%;
      background: linear-gradient(
        45deg,
        rgba(255, 255, 255, 0.7) 0%,
        rgba(255, 255, 255, 0) 40%,
        rgba(255, 255, 255, 0) 60%,
        rgba(255, 255, 255, 0.7) 100%
      );
      animation: shine 2.5s infinite;
      transform: rotate(0deg);
    }
    @keyframes shine {
      0% {
        transform: translate(-100%, -100%);
      }
      50% {
        transform: translate(100%, 100%);
      }
      100% {
        transform: translate(-100%, -100%);
      }
    }
    .keep-line-breaks {
      white-space: pre-line;
    }
    .notice-banner {
      background: linear-gradient(130deg, #002f2f, #004a3f);
      border: 1px solid #0a7f5f;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-bottom: 1rem;
      position: relative;
      overflow: hidden;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
      color: #69ffa2;
      font-weight: bold;
      text-shadow: 0 0 5px #69ffa2, 0 0 10px #69ffa2;
      transition: filter 0.3s;
      cursor: pointer;
    }
    .notice-banner:hover {
      filter: brightness(1.2);
    }
    .notice-banner p {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .video-responsive {
      position: relative;
      width: 560px;
      max-width: 100%;
      margin: 1rem 0;
    }
    .video-responsive::before {
      content: "";
      display: block;
      padding-top: 56.25%;
    }
    .video-responsive iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      border: 0;
    }
    .magic-btn {
      position: relative;
      overflow: hidden;
      color: #000;
      border-radius: 5px;
      margin-left: 5px;
      padding: 2px 6px;
      transition: box-shadow 0.3s;
    }
    .magic-btn:hover {
      box-shadow: 0 0 8px 2px rgba(255, 215, 0, 0.8);
    }
    .magic-btn:disabled {
      border: none !important;
      box-shadow: none !important;
    }
    .magic-shimmer {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.5) 50%, rgba(255,255,255,0.1) 100%);
      background-size: 200% auto;
      animation: shimmer 1.5s linear infinite;
    }
    @keyframes shimmer {
      0% { background-position: 200% center; }
      100% { background-position: -200% center; }
    }
    .magic-blessing {
      background: linear-gradient(45deg, rgba(255,215,0,0.4), rgba(255,215,0,0.8));
      animation: blessingPulse 2s ease-in-out infinite;
    }
    @keyframes blessingPulse {
      0%, 100% { box-shadow: 0 0 10px 2px rgba(255,215,0,0.8); }
      50% { box-shadow: 0 0 20px 4px rgba(255,215,0,1); }
    }
    .magic-curse {
      filter: invert(1) blur(2px);
    }
    .magic-font {
      font-family: 'Comic Neue', cursive, sans-serif !important;
      color: #d9534f;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .magic-title {
      direction: rtl;
      unicode-bidi: bidi-override;
    }
    .magic-rainbow {
      background: linear-gradient(45deg,
        rgba(255, 0, 0, 0.4),
        rgba(255, 165, 0, 0.4),
        rgba(255, 255, 0, 0.4),
        rgba(0, 128, 0, 0.4),
        rgba(0, 0, 255, 0.4),
        rgba(75, 0, 130, 0.4),
        rgba(238, 130, 238, 0.4)
      );
      animation: rainbowPulse 2s ease-in-out infinite;
    }
    @keyframes rainbowPulse {
      0%, 100% {
        box-shadow: 0 0 10px 2px rgba(255, 0, 0, 0.8);
      }
      50% {
        box-shadow: 0 0 20px 4px rgba(238, 130, 238, 1);
      }
    }
    .magic-ultimate {
      background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, rgba(0,0,0,0) 70%) !important;
      animation: ultimateGlow 2s infinite;
    }
    @keyframes ultimateGlow {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    .magic-basic {
      animation: basicGlow 2s infinite;
    }
    @keyframes basicGlow {
      0% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.5); }
      50% { box-shadow: 0 0 15px rgba(0, 255, 255, 1); }
      100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.5); }
    }
    @media (max-width: 576px) {
      .action-buttons {
        margin-left: auto;
        text-align: right;
        display: flex;
        gap: 0.1rem;
      }
    }

    /* 좋아요(추천) 버튼 타오르는 애니메이션 */
    @keyframes likeFlame {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4); /* 파란색 (Bootstrap primary 색상 계열) */
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 0 10px 6px rgba(0, 123, 255, 0.4);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4);
      }
    }
    .like-flame {
      animation: likeFlame 0.5s ease-in-out;
    }
    .adventure {
      font-family: 'Jua', sans-serif !important;
    }

    @keyframes burningAnimation {
      0% {
        filter: brightness(1) drop-shadow(0 0 5px rgba(255, 69, 0, 0.8));
      }
      50% {
        filter: brightness(1) drop-shadow(0 0 15px rgba(255, 69, 0, 1));
      }
      100% {
        filter: brightness(1) drop-shadow(0 0 5px rgba(255, 69, 0, 0.8));
      }
    }
    .burning {
      animation: burningAnimation 1.5s infinite;
    }

    /* 단일 이모지일 경우 크게 보이도록 하는 CSS */
    .emoji-large {
      font-size: 4rem; /* 원하는 크기로 조정 */
      line-height: 1;
    }

    /* Toast UI Editor 컨텐츠의 기본 글씨 크기를 18px로 설정 */
    .toastui-editor-contents {
      font-size: 16px;
    }

  /* 퀴즈 카드 전용 스타일 */
  .quiz-card {
    border: 2px solid #4CAF50;
    background: rgba(255, 255, 255, 0.9);
    color: #333;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    margin-top: 1rem;
  }
  .quiz-card .card-title {
    color: #4CAF50;
  }
  .quiz-option {
    margin: 0.3rem;
  }
  </style>
</head>
<body>
  <!-- 네비게이션 바 -->
  <nav class="navbar navbar-expand-lg navbar-dark">
    <div class="container">
      <span class="navbar-brand fw-bold">뉴프로</span>
      <div class="ms-auto">
        <button class="btn btn-outline-light me-2 auth-loading" id="authLoadingBtn">로딩중...</button>
        <button class="btn btn-outline-light me-2 d-none" id="loginBtn" data-bs-toggle="modal" data-bs-target="#loginModal">로그인</button>
        <button class="btn btn-success me-2 d-none" id="signupBtn" data-bs-toggle="modal" data-bs-target="#signupModal">회원가입</button>
        <!-- 로그인 시 보여질 사용자 프로필(드롭다운) -->
        <div class="dropdown d-none" id="userDropdown">
          <button class="btn btn-outline-light dropdown-toggle" type="button" id="userDropdownMenuButton" data-bs-toggle="dropdown" aria-expanded="false">
            <!-- 닉네임, 등급, 점수로 동적 업데이트 -->
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="userDropdownMenuButton">
            <!-- <li><a class="dropdown-item" href="#">프로필</a></li> -->
            <!-- <li><hr class="dropdown-divider"></li> -->
            <li><a class="dropdown-item" href="#" id="logoutBtnDropdown">로그아웃</a></li>
          </ul>
        </div>
      </div>
    </div>
  </nav>

  <!-- Hero Section -->
  <section class="hero-section">
    <h1 class="hero-title">코딩은 모험이다!</h1>
    <p class="hero-subtitle">뉴프로 커뮤니티에서 아이디어를 마음껏 나누고, 즐거운 코드 토크를 펼쳐보세요!</p>
  </section>

  <!-- 메인 컨테이너 -->
  <div class="container mb-5">
    <div class="d-flex justify-content-end mb-2">
      <button class="btn shining-btn me-2" id="showRankBtn" data-bs-toggle="modal" data-bs-target="#rankModal">내 계급 보기</button>
      <button class="btn btn-outline-info me-2" id="showRankingBtn" data-bs-toggle="modal" data-bs-target="#rankingModal">랭킹</button>
      <button class="btn btn-light d-none" id="togglePostFormBtn">글쓰기</button>
    </div>

    <div id="noticeContainer" class="notice-container mb-3"></div>

    <!-- 글쓰기 카드 (숨김) -->
    <div class="card glass-card p-3 d-none" id="postCard">
      <div class="card-body">
        <h5 class="card-title">새 글 작성</h5>
        <div class="mb-3">
          <label for="postTitle" class="form-label">제목</label>
          <input type="text" class="form-control" id="postTitle" placeholder="제목을 입력하세요" />
        </div>
        <div class="mb-3">
          <label for="editor" class="form-label">내용</label>
          <div id="editor"></div>
        </div>
        <button class="btn btn-primary mt-2" id="savePostBtn">글 저장하기</button>
      </div>
    </div>

    <!-- 글 목록 카드 -->
    <div class="card glass-card mt-4">
      <div class="card-body px-0 px-md-3">
        <h4 class="card-title adventure text-center">모험의 기록</h4>
        <div id="postList" class="mt-3"><!-- 게시글 목록이 로드됩니다 --></div>
      </div>
    </div>
  </div>

  <!-- [수정 모달] -->
  <div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="editModalLabel">글 수정</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="editPostId" />
          <div class="mb-3">
            <label for="editTitle" class="form-label">제목</label>
            <input type="text" class="form-control" id="editTitle" placeholder="제목을 입력하세요" />
          </div>
          <div class="mb-3">
            <label for="editContentEditor" class="form-label">내용</label>
            <div id="editContentEditor"></div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
          <button type="button" class="btn btn-success" id="updatePostBtn">수정하기</button>
        </div>
      </div>
    </div>
  </div>

  <!-- [댓글 삭제 확인 모달] -->
  <div class="modal fade" id="deleteCommentModal" tabindex="-1" aria-labelledby="deleteCommentModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="deleteCommentModalLabel">댓글 삭제</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>해당 댓글을 삭제하시겠습니까?</p>
          <input type="hidden" id="deleteCommentPostId" />
          <input type="hidden" id="deleteCommentId" />
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
          <button type="button" class="btn btn-danger" id="confirmDeleteCommentBtn">삭제</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 회원가입 모달 -->
  <div class="modal fade" id="signupModal" tabindex="-1" aria-labelledby="signupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <form id="signupForm">
          <div class="modal-header">
            <h5 class="modal-title" id="signupModalLabel">회원가입</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="mb-3">
              <label for="signupEmail" class="form-label">이메일</label>
              <input type="email" class="form-control" id="signupEmail" required />
              <small class="text-muted">올바른 이메일을 입력하면 비밀번호를 잊어버려도 계정을 찾을 수 있어요!</small>
            </div>
            <div class="mb-3">
              <label for="signupPassword" class="form-label">비밀번호</label>
              <input type="password" class="form-control" id="signupPassword" required />
            </div>
            <div class="mb-3">
              <label for="signupNickname" class="form-label">닉네임</label>
              <input type="text" class="form-control" id="signupNickname" required />
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
            <button type="submit" class="btn btn-success">회원가입</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- 로그인 모달 -->
  <div class="modal fade" id="loginModal" tabindex="-1" aria-labelledby="loginModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <form id="loginForm">
          <div class="modal-header">
            <h5 class="modal-title" id="loginModalLabel">로그인</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="mb-3">
              <label for="loginEmail" class="form-label">이메일</label>
              <input type="email" class="form-control" id="loginEmail" required />
            </div>
            <div class="mb-3">
              <label for="loginPassword" class="form-label">비밀번호</label>
              <input type="password" class="form-control" id="loginPassword" required />
            </div>
            <div class="text-end">
              <button type="button" id="resetPasswordBtn" class="btn btn-link btn-sm">비밀번호 찾기</button>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
            <button type="submit" class="btn btn-primary">로그인</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- [계급 안내 모달] -->
  <div class="modal fade" id="rankModal" tabindex="-1" aria-labelledby="rankModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="rankModalLabel">내 계급 안내</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p><strong>내 점수</strong>: <span id="myScore">로딩중...</span></p>
          <p><strong>내 계급</strong>: <span id="myRank">로딩중...</span></p>
          <hr/>
          <h6>계급 기준</h6>
          <ul style="font-size:0.95rem;" id="futureMagicList"><!-- 동적 채움 --></ul>
          <small class="text-muted">
            행동별 점수: 글쓰기 +50, 댓글 +20, 좋아요 +10, 싫어요 -5
          </small>
          <div class="mt-3">
            <button class="btn btn-secondary btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#accountCollapse" aria-expanded="false" aria-controls="accountCollapse">
              계정 관리
            </button>
            <div class="collapse mt-2" id="accountCollapse">
              <div class="card card-body">
                <button id="deleteAccountBtn" class="btn btn-danger btn-sm">회원탈퇴</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- [랭킹 모달] -->
  <div class="modal fade" id="rankingModal" tabindex="-1" aria-labelledby="rankingModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="rankingModalLabel">랭킹</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="rankingContainer" style="max-height: 70vh; overflow-y: auto;">
          <!-- Firestore users 랭킹 항목들이 무한 스크롤로 로드됩니다 -->
        </div>
      </div>
    </div>
  </div>

  <!-- [마법 모달] -->
  <div class="modal fade" id="magicModal" tabindex="-1" aria-labelledby="magicModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="magicModalLabel">마법 사용</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="magicPostId" />
          <div id="magicInfo"><!-- 동적 채움 --></div>
        </div>
        <div class="modal-footer" id="magicModalFooter">
          <!-- 버튼은 상황에 따라 동적으로 생성됩니다 -->
        </div>
      </div>
    </div>
  </div>

  <!-- Toast (알림) -->
  <div class="toast-container">
    <div id="liveToast" class="toast align-items-center dark-bg" role="alert" aria-live="assertive" aria-atomic="true">
      <div class="toast-header">
        <strong class="me-auto" id="toastTitle">알림</strong>
        <small class="text-muted" id="toastTime"></small>
        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
      <div class="toast-body" id="toastMessage">메시지 내용</div>
    </div>
  </div>

  <!-- canvas-confetti -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Firebase ES Modules (모듈 방식) -->
  <script type="module">
    /********************************
     * Firebase 초기화 및 모듈 임포트
     ********************************/
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.2.0/firebase-app.js';
    import { initializeAppCheck, ReCaptchaV3Provider } from 'https://www.gstatic.com/firebasejs/11.2.0/firebase-app-check.js';
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail, deleteUser } from 'https://www.gstatic.com/firebasejs/11.2.0/firebase-auth.js';
    import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, deleteDoc, runTransaction, serverTimestamp, arrayUnion, arrayRemove, where, query, orderBy, getDocs, startAfter, limit, onSnapshot, Timestamp, deleteField } from 'https://www.gstatic.com/firebasejs/11.2.0/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyC-etI5o4uWbBp2Arj9KpxdDyRebguErnY",
      authDomain: "newpro-4bc73.firebaseapp.com",
      projectId: "newpro-4bc73",
      storageBucket: "newpro-4bc73.firebasestorage.app",
      messagingSenderId: "267192611563",
      appId: "1:267192611563:web:94fb5ec97872cd452a84ae"
    };

    const app = initializeApp(firebaseConfig);
    initializeAppCheck(app, {
      provider: new ReCaptchaV3Provider('6LcKb8QqAAAAAKReI1hvkatzxiNvquuoryudyXi4'),
      isTokenAutoRefreshEnabled: true
    });
    const auth = getAuth(app);
    const db = getFirestore(app);

    /********************************
     * 전역 사용자 캐시 및 함수
     ********************************/
    const userCache = {}; // uid별 캐시
    async function fetchUserDoc(uid) {
      if (userCache[uid]) {
        return { exists: () => true, data: () => userCache[uid] };
      }
      const userRef = doc(db, 'users', uid);
      const snap = await getDoc(userRef);
      if (snap.exists()) {
        userCache[uid] = snap.data();
      }
      return snap;
    }
    async function fetchUserNicknameAndScore(uid) {
      const snap = await fetchUserDoc(uid);
      if (snap.exists()) {
        const data = snap.data();
        return { nickname: data.nickname || null, score: data.score || 0 };
      }
      return { nickname: null, score: 0 };
    }

    /********************************
     * Toast UI Editor 및 DOMPurify 초기화
     ********************************/
    const { Editor } = toastui;
    const { codeSyntaxHighlight } = Editor.plugin;
    let createEditor = new Editor({
      el: document.querySelector('#editor'),
      initialEditType: 'wysiwyg',
      previewStyle: 'vertical',
      plugins: [codeSyntaxHighlight]
    });
    let editEditor = new Editor({
      el: document.querySelector('#editContentEditor'),
      initialEditType: 'wysiwyg',
      previewStyle: 'vertical',
      plugins: [codeSyntaxHighlight]
    });

    const quizQuestionsAll = [
      { question: "자바 문법에서 프로그램의 시작점은 무엇인가요?", options: ["main", "start", "run", "init"], answer: "main" },
      { question: "자바스크립트 문법에서 JavaScript를 개발한 회사는 어디인가요?", options: ["Netscape", "Microsoft", "Google", "Apple"], answer: "Netscape" },
      { question: "CPU는 무엇의 약자인가요?", options: ["Central Processing Unit", "Computer Personal Unit", "Central Performance Unit", "Control Processing Unit"], answer: "Central Processing Unit" },
      { question: "자바 문법에서 JVM은 무엇의 약자인가요?", options: ["Java Virtual Machine", "Java Variable Method", "Just Virtual Memory", "없음"], answer: "Java Virtual Machine" },
      { question: "자바스크립트 문법에서 클로저(closure)란 무엇인가요?", options: ["자신의 렉시컬 환경을 기억하는 함수", "단순 함수", "즉시 실행 함수", "콜백 함수"], answer: "자신의 렉시컬 환경을 기억하는 함수" },
      { question: "RAM은 무엇의 약자인가요?", options: ["Random Access Memory", "Readily Available Memory", "Run Access Memory", "없음"], answer: "Random Access Memory" },
      { question: "자바 문법에서 클래스를 상속할 때 사용하는 키워드는 무엇인가요?", options: ["extends", "implements", "inherits", "super"], answer: "extends" },
      { question: "자바스크립트 문법에서 'this'는 무엇을 가리키나요?", options: ["현재 함수를 실행하는 객체", "전역 객체", "undefined", "없음"], answer: "현재 함수를 실행하는 객체" },
      { question: "HTML의 풀 네임은 무엇인가요?", options: ["Hyper Text Markup Language", "High Text Machine Language", "Hyperlinks and Text Markup Language", "없음"], answer: "Hyper Text Markup Language" },
      { question: "자바 문법에서 다음 중 Java의 특징이 아닌 것은 무엇인가요?", options: ["포인터", "객체지향", "이식성", "동적"], answer: "포인터" },
      { question: "자바스크립트 문법에서 한 줄 주석을 나타내는 기호는 무엇인가요?", options: ["//", "<!--", "#", "%%"], answer: "//" },
      { question: "이진 탐색의 시간 복잡도는 얼마인가요?", options: ["O(log n)", "O(n)", "O(n log n)", "O(1)"], answer: "O(log n)" },
      { question: "자바 문법에서 중복된 요소를 허용하지 않는 컬렉션은 무엇인가요?", options: ["Set", "List", "Map", "Array"], answer: "Set" },
      { question: "자바스크립트 문법에서 JSON 문자열을 객체로 변환하는 메서드는 무엇인가요?", options: ["JSON.parse", "JSON.stringify", "JSON.toObject", "JSON.convert"], answer: "JSON.parse" },
      { question: "API는 무엇의 약자인가요?", options: ["Application Programming Interface", "Advanced Programming Interface", "Application Protocol Interface", "없음"], answer: "Application Programming Interface" },
      { question: "자바 문법에서 예외를 처리할 때 사용하는 키워드는 무엇인가요?", options: ["try", "catch", "finally", "throw"], answer: "catch" },
      { question: "자바스크립트 문법에서 JavaScript 프레임워크 중 하나는 무엇인가요?", options: ["React", "Django", "Laravel", "Spring"], answer: "React" },
      { question: "SQL의 풀 네임은 무엇인가요?", options: ["Structured Query Language", "Simple Query Language", "Standard Query Language", "없음"], answer: "Structured Query Language" },
      { question: "자바 문법에서 스레드를 시작하는 메서드는 무엇인가요?", options: ["start()", "run()", "init()", "execute()"], answer: "start()" },
      { question: "자바스크립트 문법에서 값과 타입을 모두 비교하는 연산자는 무엇인가요?", options: ["===", "==", "!==", "="], answer: "===" },
      { question: "GPU는 무엇의 약자인가요?", options: ["Graphics Processing Unit", "General Processing Unit", "Graphics Performance Unit", "없음"], answer: "Graphics Processing Unit" },
      { question: "자바 문법에서 int 자료형의 크기는 몇 비트인가요?", options: ["32", "16", "64", "8"], answer: "32" },
      { question: "자바스크립트 문법에서 배열의 마지막 요소를 제거하는 메서드는 무엇인가요?", options: ["pop()", "push()", "shift()", "unshift()"], answer: "pop()" },
      { question: "운영체제의 주된 역할은 무엇인가요?", options: ["하드웨어와 소프트웨어 자원 관리", "하드웨어 관리만", "소프트웨어 관리만", "없음"], answer: "하드웨어와 소프트웨어 자원 관리" },
      { question: "자바 문법에서 객체를 생성할 때 사용하는 키워드는 무엇인가요?", options: ["new", "create", "init", "object"], answer: "new" },
      { question: "자바스크립트 문법에서 배열의 끝에 요소를 추가하는 메서드는 무엇인가요?", options: ["push()", "pop()", "shift()", "unshift()"], answer: "push()" },
      { question: "DNS의 풀 네임은 무엇인가요?", options: ["Domain Name System", "Digital Network Service", "Distributed Name Service", "Domain Numbering System"], answer: "Domain Name System" },
      { question: "자바 문법에서 문자열 비교에 사용하는 메서드는 무엇인가요?", options: ["equals()", "==", "compareTo()", "equal()"], answer: "equals()" },
      { question: "자바스크립트 문법에서 상수를 선언할 때 사용하는 키워드는 무엇인가요?", options: ["const", "var", "let", "static"], answer: "const" },
      { question: "HTTP의 풀 네임은 무엇인가요?", options: ["HyperText Transfer Protocol", "HyperText Transmission Protocol", "HighText Transfer Protocol", "없음"], answer: "HyperText Transfer Protocol" },
      { question: "자바 문법에서 모든 클래스의 상위 클래스는 무엇인가요?", options: ["Object", "Class", "Base", "Super"], answer: "Object" },
      { question: "자바스크립트 문법에서 문자열을 정수로 변환하는 함수는 무엇인가요?", options: ["parseInt()", "parseFloat()", "Number()", "convert()"], answer: "parseInt()" },
      { question: "URL의 풀 네임은 무엇인가요?", options: ["Uniform Resource Locator", "Universal Resource Link", "Uniform Resource Link", "Unique Resource Locator"], answer: "Uniform Resource Locator" },
      { question: "자바 문법에서 0으로 나눌 때 발생하는 예외는 무엇인가요?", options: ["ArithmeticException", "NullPointerException", "NumberFormatException", "IOException"], answer: "ArithmeticException" },
      { question: "자바스크립트 문법에서 객체를 JSON 문자열로 변환하는 메서드는 무엇인가요?", options: ["JSON.stringify()", "JSON.parse()", "JSON.convert()", "JSON.objectify()"], answer: "JSON.stringify()" },
      { question: "이진수 1010의 10진수 값은 얼마인가요?", options: ["10", "11", "12", "9"], answer: "10" },
      { question: "자바 문법에서 서브클래스를 만들 때 사용하는 키워드는 무엇인가요?", options: ["extends", "implements", "inherits", "super"], answer: "extends" },
      { question: "자바스크립트 문법에서 한 줄 주석을 나타내는 기호는 무엇인가요?", options: ["//", "/*", "#", "--"], answer: "//" },
      { question: "LAN은 무엇의 약자인가요?", options: ["Local Area Network", "Large Area Network", "Long Area Network", "없음"], answer: "Local Area Network" },
      { question: "자바 문법에서 문자열 연결에 사용하는 연산자는 무엇인가요?", options: ["+", "&", "*", "."], answer: "+" },
      { question: "자바스크립트 문법에서 소수를 반올림하는 메서드는 무엇인가요?", options: ["Math.round()", "Math.floor()", "Math.ceil()", "parseInt()"], answer: "Math.round()" },
      { question: "컴파일러의 주된 역할은 무엇인가요?", options: ["소스 코드를 기계어로 번역", "코드 실행", "디버깅", "코드 저장"], answer: "소스 코드를 기계어로 번역" },
      { question: "자바 문법에서 배열의 길이를 구하는 속성은 무엇인가요?", options: ["length", "size()", "count()", "getLength()"], answer: "length" },
      { question: "자바스크립트 문법에서 문자열 좌우의 공백을 제거하는 메서드는 무엇인가요?", options: ["trim()", "strip()", "clean()", "remove()"], answer: "trim()" },
      { question: "O(n log n) 시간 복잡도를 가지는 정렬 알고리즘은 무엇인가요?", options: ["Merge Sort", "Bubble Sort", "Insertion Sort", "Selection Sort"], answer: "Merge Sort" },
      { question: "자바 문법에서 사용자 정의 비교기를 만들 때 구현해야 하는 인터페이스는 무엇인가요?", options: ["Comparator", "Comparable", "ComparatorInterface", "SortingInterface"], answer: "Comparator" },
      { question: "자바스크립트 문법에서 배열의 앞쪽에 요소를 추가하는 메서드는 무엇인가요?", options: ["unshift()", "push()", "shift()", "pop()"], answer: "unshift()" },
      { question: "SSD는 무엇의 약자인가요?", options: ["Solid State Drive", "Super Speed Drive", "Standard State Disk", "없음"], answer: "Solid State Drive" },
      { question: "자바 문법에서 파일을 찾지 못했을 때 발생하는 예외는 무엇인가요?", options: ["FileNotFoundException", "IOException", "NullPointerException", "RuntimeException"], answer: "FileNotFoundException" },
      { question: "자바스크립트 문법에서 배열인지 확인하는 내장 메서드는 무엇인가요?", options: ["Array.isArray()", "typeof", "instanceof", "isArray()"], answer: "Array.isArray()" },
      { question: "안전한 통신을 위해 주로 사용하는 프로토콜은 무엇인가요?", options: ["HTTPS", "HTTP", "FTP", "SMTP"], answer: "HTTPS" },
      { question: "자바 문법에서 상속을 방지할 때 사용하는 키워드는 무엇인가요?", options: ["final", "static", "private", "const"], answer: "final" },
      { question: "자바스크립트 문법에서 코드 실행을 지연시키는 함수는 무엇인가요?", options: ["setTimeout()", "setInterval()", "delay()", "wait()"], answer: "setTimeout()" },
      { question: "빅오 표기법은 무엇을 설명하는가요?", options: ["알고리즘 효율성", "코드 작성", "메모리 관리", "없음"], answer: "알고리즘 효율성" },
      { question: "자바 문법에서 int를 감싸는 Wrapper 클래스는 무엇인가요?", options: ["Integer", "intWrapper", "Number", "Byte"], answer: "Integer" },
      { question: "자바스크립트 문법에서 변수에 값을 할당할 때 사용하는 연산자는 무엇인가요?", options: ["=", "==", "===", ":="], answer: "=" },
      { question: "넓은 지역을 커버하는 네트워크는 무엇인가요?", options: ["WAN", "LAN", "MAN", "PAN"], answer: "WAN" },
      { question: "자바 문법에서 문자열을 대문자로 변환하는 메서드는 무엇인가요?", options: ["toUpperCase()", "toUpper()", "upperCase()", "capitalize()"], answer: "toUpperCase()" },
      { question: "자바스크립트 문법에서 날짜와 시간을 나타내는 내장 객체는 무엇인가요?", options: ["Date", "Time", "Moment", "Calendar"], answer: "Date" },
      { question: "BIOS의 풀 네임은 무엇인가요?", options: ["Basic Input/Output System", "Binary Input/Output System", "Basic Internal Operating System", "없음"], answer: "Basic Input/Output System" },
      { question: "자바 문법에서 상위 클래스의 생성자를 호출할 때 사용하는 키워드는 무엇인가요?", options: ["super", "this", "parent", "base"], answer: "super" },
      { question: "자바스크립트 문법에서 문자열의 길이를 반환하는 속성은 무엇인가요?", options: ["length", "size", "count", "charCount"], answer: "length" },
      { question: "컴퓨터에서 가장 작은 데이터 단위는 무엇인가요?", options: ["Bit", "Byte", "Nibble", "Word"], answer: "Bit" },
      { question: "자바 문법에서 LIFO 원칙을 따르는 자료구조는 무엇인가요?", options: ["Stack", "Queue", "List", "Set"], answer: "Stack" },
      { question: "자바스크립트 문법에서 배열의 각 요소를 변환하여 새로운 배열을 만드는 메서드는 무엇인가요?", options: ["map()", "filter()", "sort()", "reduce()"], answer: "map()" },
      { question: "O(n²) 시간 복잡도를 가지는 대표적인 정렬 알고리즘은 무엇인가요?", options: ["Bubble Sort", "Quick Sort", "Merge Sort", "Heap Sort"], answer: "Bubble Sort" },
      { question: "자바 문법에서 중복된 요소를 허용하는 컬렉션은 무엇인가요?", options: ["List", "Set", "Map", "Queue"], answer: "List" },
      { question: "자바스크립트 문법에서 사용자가 요소를 클릭할 때 발생하는 이벤트는 무엇인가요?", options: ["click", "onchange", "hover", "keydown"], answer: "click" },
      { question: "소프트웨어의 오류를 찾아 수정하는 과정을 무엇이라고 하나요?", options: ["디버깅", "컴파일", "실행", "설계"], answer: "디버깅" },
      { question: "자바 문법에서 현재 객체 자신을 가리키는 키워드는 무엇인가요?", options: ["this", "self", "current", "object"], answer: "this" },
      { question: "자바스크립트 문법에서 숫자를 문자열로 변환하는 메서드는 무엇인가요?", options: ["toString()", "parseInt()", "String()", "convert()"], answer: "toString()" },
      { question: "OSI 7계층 중 라우팅을 담당하는 계층은 무엇인가요?", options: ["네트워크 계층", "데이터 링크 계층", "전송 계층", "응용 계층"], answer: "네트워크 계층" },
      { question: "자바 문법에서 배열의 잘못된 인덱스에 접근할 때 발생하는 예외는 무엇인가요?", options: ["ArrayIndexOutOfBoundsException", "NullPointerException", "IllegalArgumentException", "ClassCastException"], answer: "ArrayIndexOutOfBoundsException" },
      { question: "자바스크립트 문법에서 값과 타입을 엄격하게 비교하는 연산자는 무엇인가요?", options: ["===", "==", "!=", "!=="], answer: "===" },
      { question: "GPU는 컴퓨터에서 어떤 역할을 하나요?", options: ["그래픽 처리", "일반 연산", "메모리 관리", "없음"], answer: "그래픽 처리" },
      { question: "자바 문법에서 컬렉션을 순회할 때 사용하는 인터페이스는 무엇인가요?", options: ["Iterator", "Iterable", "Collection", "ListIterator"], answer: "Iterator" },
      { question: "자바스크립트 문법에서 배열에서 특정 요소의 인덱스를 찾는 메서드는 무엇인가요?", options: ["indexOf()", "findIndex()", "search()", "locate()"], answer: "indexOf()" },
      { question: "IP 주소의 주 목적은 무엇인가요?", options: ["네트워크 상의 장치 식별", "데이터 저장", "정보 처리", "없음"], answer: "네트워크 상의 장치 식별" },
      { question: "자바 문법에서 여러 예외를 하나의 catch 블록으로 처리할 때 사용하는 구분자는 무엇인가요?", options: ["| (파이프)", "& (앰퍼샌드)", ", (쉼표)", "없음"], answer: "| (파이프)" },
      { question: "자바스크립트 문법에서 데이터 타입 중 하나가 아닌 것은 무엇인가요?", options: ["Undefined", "Integer", "Boolean", "Object"], answer: "Integer" },
      { question: "재귀(recursion)란 무엇인가요?", options: ["함수가 자기 자신을 호출하는 것", "반복문", "조건문", "없음"], answer: "함수가 자기 자신을 호출하는 것" },
      { question: "자바 문법에서 새 스레드를 생성하는 메서드는 무엇인가요?", options: ["start()", "run()", "execute()", "init()"], answer: "start()" },
      { question: "자바스크립트 문법에서 두 배열을 결합하는 메서드는 무엇인가요?", options: ["concat()", "merge()", "join()", "combine()"], answer: "concat()" },
      { question: "DNS는 네트워크에서 어떤 역할을 하나요?", options: ["도메인 이름을 IP 주소로 변환", "데이터 전송", "파일 저장", "없음"], answer: "도메인 이름을 IP 주소로 변환" },
      { question: "자바 문법에서 객체의 동등성을 비교할 때 사용하는 메서드는 무엇인가요?", options: ["equals()", "==", "===", "!="], answer: "equals()" },
      { question: "자바스크립트 문법에서 조건에 맞는 첫 번째 요소를 찾는 배열 메서드는 무엇인가요?", options: ["find()", "filter()", "map()", "reduce()"], answer: "find()" },
      { question: "SSD는 무엇의 약자인가요?", options: ["Solid State Drive", "Super Speed Drive", "Standard Storage Device", "없음"], answer: "Solid State Drive" },
      { question: "자바 문법에서 상수를 선언할 때 사용하는 키워드는 무엇인가요?", options: ["final", "const", "static", "immutable"], answer: "final" },
      { question: "자바스크립트 문법에서 현재 날짜와 시간을 반환하는 메서드는 무엇인가요?", options: ["new Date()", "Date.now()", "getTime()", "time()"], answer: "new Date()" },
      { question: "ASCII의 풀 네임은 무엇인가요?", options: ["American Standard Code for Information Interchange", "American System Code for Internet Interconnection", "Automated Standard Code for Internal Information", "없음"], answer: "American Standard Code for Information Interchange" },
      { question: "자바 문법에서 반복문을 조기 종료할 때 사용하는 키워드는 무엇인가요?", options: ["break", "continue", "exit", "return"], answer: "break" },
      { question: "자바스크립트 문법에서 배열의 첫 번째 요소를 제거하는 메서드는 무엇인가요?", options: ["shift()", "pop()", "slice()", "splice()"], answer: "shift()" },
      { question: "URL의 풀 네임은 무엇인가요?", options: ["Uniform Resource Locator", "Universal Resource Link", "Unique Resource Locator", "없음"], answer: "Uniform Resource Locator" },
      { question: "자바 문법에서 다음 중 원시 자료형이 아닌 것은 무엇인가요?", options: ["String", "int", "boolean", "char"], answer: "String" },
      { question: "자바스크립트 문법에서 조건을 만족하는 요소들로 새 배열을 만드는 메서드는 무엇인가요?", options: ["filter()", "map()", "reduce()", "forEach()"], answer: "filter()" },
      { question: "OS의 풀 네임은 무엇인가요?", options: ["Operating System", "Open Software", "Organized System", "없음"], answer: "Operating System" },
      { question: "자바 문법에서 null 객체 참조에 접근할 때 발생하는 예외는 무엇인가요?", options: ["NullPointerException", "IllegalStateException", "IOException", "RuntimeException"], answer: "NullPointerException" },
      { question: "자바스크립트 문법에서 문자열 연결에 사용하는 연산자는 무엇인가요?", options: ["+", "&", "*", "."], answer: "+" },
      { question: "데이터베이스 관리 시스템의 주된 역할은 무엇인가요?", options: ["데이터 저장 및 관리", "수학 계산", "사용자 인터페이스 디자인", "없음"], answer: "데이터 저장 및 관리" },
      { question: "자바 문법에서 멀티스레딩을 구현할 때 주로 사용하는 것은 무엇인가요?", options: ["Thread", "Process", "Coroutine", "Fiber"], answer: "Thread" },
      { question: "자바 문법에서 제네릭(Generic)을 사용하는 주된 목적은 무엇인가요?", options: ["타입 안전성 보장", "코드 간결성", "성능 향상", "메모리 최적화"], answer: "타입 안전성 보장" },
      { question: "자바 문법에서 오버라이딩과 오버로딩의 핵심 차이점은 무엇인가요?", options: ["메서드 이름은 같으나 매개변수 목록이 다름", "리턴 타입만 다름", "접근 제어자 차이", "둘 다 해당"], answer: "메서드 이름은 같으나 매개변수 목록이 다름" },
      { question: "자바 문법에서 인터페이스와 추상 클래스의 주요 차이점은 무엇인가요?", options: ["다중 상속 지원 여부", "메서드 구현 제공 여부", "생성자 존재 여부", "모두 해당"], answer: "모두 해당" },
      { question: "자바 문법에서 enum을 사용하는 주된 목적은 무엇인가요?", options: ["상수 집합 정의", "클래스 상속", "동적 메모리 할당", "없음"], answer: "상수 집합 정의" },
      { question: "자바 문법에서 Stream API의 주요 장점은 무엇인가요?", options: ["병렬 처리 지원과 코드 간결성", "메모리 절약", "예외 처리 강화", "없음"], answer: "병렬 처리 지원과 코드 간결성" },
      { question: "자바 문법에서 try-with-resources 구문의 장점은 무엇인가요?", options: ["자원 자동 해제", "예외 무시", "코드 단순화", "성능 향상"], answer: "자원 자동 해제" },
      { question: "자바 문법에서 람다 표현식의 주요 이점은 무엇인가요?", options: ["코드 간결성", "성능 향상", "동기화 제공", "메모리 최적화"], answer: "코드 간결성" },
      { question: "자바 문법에서 Optional 클래스를 사용하는 주된 목적은 무엇인가요?", options: ["NullPointerException 예방", "메모리 최적화", "스레드 안전", "없음"], answer: "NullPointerException 예방" },
      { question: "자바 문법에서 final 키워드의 용도는 무엇인가요?", options: ["값 변경 불가", "메서드 오버라이딩 방지", "클래스 상속 금지", "모두 해당"], answer: "모두 해당" },
      { question: "자바 문법에서 Reflection API를 사용하면 어떤 작업을 수행할 수 있나요?", options: ["런타임에 클래스 정보 접근", "코드 컴파일", "정적 타입 검사", "없음"], answer: "런타임에 클래스 정보 접근" },
      { question: "자바 문법에서 ConcurrentHashMap의 주요 특징은 무엇인가요?", options: ["스레드 안전", "락 분할", "높은 동시성", "모두 해당"], answer: "모두 해당" },
      { question: "자바 문법에서 Fork/Join 프레임워크의 주 용도는 무엇인가요?", options: ["병렬 처리", "파일 입출력", "데이터베이스 연결", "네트워킹"], answer: "병렬 처리" },
      { question: "자바 문법에서 ClassLoader의 주된 역할은 무엇인가요?", options: ["클래스의 동적 로딩", "메모리 관리", "네트워크 통신", "없음"], answer: "클래스의 동적 로딩" },
      { question: "자바 문법에서 어노테이션(Annotations)의 주요 목적은 무엇인가요?", options: ["메타데이터 제공", "메서드 오버라이딩", "인터페이스 구현", "메모리 할당"], answer: "메타데이터 제공" },
      { question: "자바 문법에서 JIT 컴파일러의 역할은 무엇인가요?", options: ["바이트코드를 기계어로 변환", "메모리 관리", "스레드 스케줄링", "없음"], answer: "바이트코드를 기계어로 변환" },
      { question: "자바 문법에서 CompletableFuture를 사용하는 주된 목적은 무엇인가요?", options: ["비동기 프로그래밍", "동기 프로그래밍", "데이터베이스 연결", "없음"], answer: "비동기 프로그래밍" },
      { question: "자바 문법에서 Immutable 클래스의 특징은 무엇인가요?", options: ["상태 변경 불가", "스레드 안전", "캐싱 가능", "모두 해당"], answer: "모두 해당" },
      { question: "자바 문법에서 메서드 참조(Method Reference)는 무엇인가요?", options: ["람다 표현식의 축약형", "클래스 상속 기법", "예외 처리 방식", "없음"], answer: "람다 표현식의 축약형" },
      { question: "자바 문법에서 내부 클래스(Inner Class)를 사용하는 주요 목적은 무엇인가요?", options: ["캡슐화 강화", "코드 구조 개선", "외부 클래스의 멤버 접근", "모두 해당"], answer: "모두 해당" },
      { question: "자바 문법에서 Stream의 filter() 메서드는 어떤 역할을 하나요?", options: ["조건에 맞는 요소만 선택", "요소 변환", "요소 정렬", "요소 합산"], answer: "조건에 맞는 요소만 선택" },
      { question: "자바 문법에서 parallelStream()을 사용하면 어떤 효과가 있나요?", options: ["병렬 처리", "동기 처리", "순차 처리", "성능 저하"], answer: "병렬 처리" },
      { question: "자바 문법에서 synchronized 키워드의 주된 목적은 무엇인가요?", options: ["스레드 안전 보장", "메모리 최적화", "성능 향상", "코드 간결성"], answer: "스레드 안전 보장" },
      { question: "자바 문법에서 volatile 키워드의 기능은 무엇인가요?", options: ["변수의 가시성 보장", "메서드 오버라이딩 방지", "객체 불변성", "없음"], answer: "변수의 가시성 보장" },
      { question: "자바 문법에서 Optional.ifPresent() 메서드의 역할은 무엇인가요?", options: ["값이 존재할 때 실행", "값 제거", "null 체크", "없음"], answer: "값이 존재할 때 실행" },
      { question: "자바 문법에서 Collectors.joining() 메서드는 주로 무엇에 사용되나요?", options: ["문자열 결합", "데이터 정렬", "요소 필터링", "병렬 처리"], answer: "문자열 결합" },
      { question: "자바 문법에서 메서드 참조 사용 시 주의해야 할 사항은 무엇인가요?", options: ["매개변수와 리턴 타입 일치, 예외 처리", "오직 매개변수만 일치", "리턴 타입만 일치", "없음"], answer: "매개변수와 리턴 타입 일치, 예외 처리" },
      { question: "자바 문법에서 finally 블록의 특징은 무엇인가요?", options: ["항상 실행", "예외 무시", "조건부 실행", "실행되지 않을 수 있음"], answer: "항상 실행" },
      { question: "자바 문법에서 Reflection API 사용 시 주의해야 할 점은 무엇인가요?", options: ["성능 저하, 보안 취약점, 유지보수 어려움", "메모리 누수", "속도 저하만", "없음"], answer: "성능 저하, 보안 취약점, 유지보수 어려움" },
      { question: "자바 문법에서 모듈 시스템의 주요 목적은 무엇인가요?", options: ["의존성 관리", "병렬 처리", "메모리 관리", "인터페이스 개선"], answer: "의존성 관리" },
      { question: "자바 문법에서 Stream의 collect() 메서드는 주로 어떤 역할을 하나요?", options: ["스트림 결과를 컬렉션으로 변환", "요소 필터링", "요소 합산", "정렬"], answer: "스트림 결과를 컬렉션으로 변환" },
      { question: "자바 문법에서 인스턴스 초기화 블록의 특징은 무엇인가요?", options: ["객체 생성 시 실행", "클래스 로딩 시 실행", "정적 초기화", "없음"], answer: "객체 생성 시 실행" },
      { question: "자바 문법에서 new 연산자의 역할은 무엇인가요?", options: ["객체 생성, 메모리 할당, 생성자 호출", "메서드 실행", "클래스 로딩", "없음"], answer: "객체 생성, 메모리 할당, 생성자 호출" },
      { question: "자바 문법에서 @Override 어노테이션의 목적은 무엇인가요?", options: ["컴파일러에 오버라이딩 검증을 요청", "성능 향상", "메모리 최적화", "코드 축약"], answer: "컴파일러에 오버라이딩 검증을 요청" },
      { question: "자바 문법에서 enum에 메서드를 정의할 수 있는 이유는 무엇인가요?", options: ["enum이 클래스와 유사하기 때문", "enum은 인터페이스임", "메모리 최적화", "없음"], answer: "enum이 클래스와 유사하기 때문" },
      { question: "자바 문법에서 자동 박싱(Autoboxing)의 주요 이점은 무엇인가요?", options: ["코드 간결성", "성능 향상", "메모리 절약", "동기화 지원"], answer: "코드 간결성" },
      { question: "자바스크립트 문법에서 클로저를 이용한 데이터 은닉의 주요 장점은 무엇인가요?", options: ["캡슐화", "메모리 최적화", "코드 간결성", "동기화"], answer: "캡슐화" },
      { question: "자바스크립트 문법에서 프로토타입 체인의 역할은 무엇인가요?", options: ["객체 상속", "메모리 관리", "비동기 처리", "없음"], answer: "객체 상속" },
      { question: "자바스크립트 문법에서 async/await를 사용하면 어떤 이점이 있나요?", options: ["비동기 코드를 동기적으로 표현", "성능 향상", "메모리 절약", "없음"], answer: "비동기 코드를 동기적으로 표현" },
      { question: "자바스크립트 문법에서 Promise의 상태는 어떤 값들을 가질 수 있나요?", options: ["pending, fulfilled, rejected", "start, run, end", "open, closed, error", "없음"], answer: "pending, fulfilled, rejected" },
      { question: "자바스크립트 문법에서 동적으로 객체 프로퍼티를 추가할 때 주로 사용하는 표기법은 무엇인가요?", options: ["대괄호 표기법", "점 표기법", "둘 다", "없음"], answer: "대괄호 표기법" },
      { question: "자바스크립트 문법에서 'use strict'를 사용하는 주된 이유는 무엇인가요?", options: ["엄격한 문법 적용", "코드 압축", "동적 변수 생성 방지", "없음"], answer: "엄격한 문법 적용" },
      { question: "자바스크립트 문법에서 클로저를 사용해 private 변수를 구현할 수 있는 이유는 무엇인가요?", options: ["함수가 렉시컬 스코프를 기억하기 때문", "전역 스코프 때문", "객체 지향 특성 때문", "없음"], answer: "함수가 렉시컬 스코프를 기억하기 때문" },
      { question: "자바스크립트 문법에서 Event Loop의 주된 역할은 무엇인가요?", options: ["비동기 작업 처리", "동기 코드 실행", "메모리 관리", "없음"], answer: "비동기 작업 처리" },
      { question: "자바스크립트 문법에서 Array.prototype.map()과 forEach()의 차이점은 무엇인가요?", options: ["map()은 새 배열 반환, forEach()는 반환 없음", "둘 다 새 배열 반환", "둘 다 반환 없음", "없음"], answer: "map()은 새 배열 반환, forEach()는 반환 없음" },
      { question: "자바스크립트 문법에서 객체의 깊은 복사와 얕은 복사의 차이는 무엇인가요?", options: ["참조 복사 여부", "메모리 사용량", "속도 차이", "모두 해당"], answer: "참조 복사 여부" },
      { question: "자바스크립트 문법에서 모듈 시스템(ES6 Modules)의 주요 장점은 무엇인가요?", options: ["코드 캡슐화와 의존성 관리", "코드 압축", "비동기 처리", "없음"], answer: "코드 캡슐화와 의존성 관리" },
      { question: "자바스크립트 문법에서 Symbol의 주요 용도는 무엇인가요?", options: ["고유 식별자 생성", "문자열 변환", "숫자 계산", "없음"], answer: "고유 식별자 생성" },
      { question: "자바스크립트 문법에서 Proxy 객체를 사용하는 주요 이유는 무엇인가요?", options: ["객체의 동작을 제어하기 위해", "메모리 최적화", "비동기 처리", "없음"], answer: "객체의 동작을 제어하기 위해" },
      { question: "자바스크립트 문법에서 Reflect API의 주요 목적은 무엇인가요?", options: ["객체 조작 메서드 제공", "비동기 처리", "에러 핸들링", "없음"], answer: "객체 조작 메서드 제공" },
      { question: "자바스크립트 문법에서 Generator 함수의 핵심 특징은 무엇인가요?", options: ["yield 키워드 사용", "동기 처리", "메모리 절약", "없음"], answer: "yield 키워드 사용" },
      { question: "자바스크립트 문법에서 옵셔널 체이닝(Optional Chaining)의 주요 이점은 무엇인가요?", options: ["undefined 방지, 코드 간결성, 오류 예방", "메모리 최적화", "속도 향상", "없음"], answer: "undefined 방지, 코드 간결성, 오류 예방" },
      { question: "자바스크립트 문법에서 Nullish 병합 연산자(??)는 주로 무엇을 처리하기 위한 연산자인가요?", options: ["null 또는 undefined 값", "숫자 계산", "문자열 연결", "없음"], answer: "null 또는 undefined 값" },
      { question: "자바스크립트 문법에서 비구조화 할당(Destructuring Assignment)의 주요 이점은 무엇인가요?", options: ["코드 간결성, 데이터 추출 용이, 가독성 향상", "메모리 절약", "속도 향상", "없음"], answer: "코드 간결성, 데이터 추출 용이, 가독성 향상" },
      { question: "자바스크립트 문법에서 Spread 연산자의 주된 용도는 무엇인가요?", options: ["배열 복사 및 결합, 객체 확장, 함수 인자 전달", "문자열 연결", "숫자 계산", "없음"], answer: "배열 복사 및 결합, 객체 확장, 함수 인자 전달" },
      { question: "자바스크립트 문법에서 클로저를 활용한 메모이제이션의 주요 목적은 무엇인가요?", options: ["함수 결과 캐싱", "코드 단순화", "동기화", "없음"], answer: "함수 결과 캐싱" },
      { question: "자바스크립트 문법에서 IIFE(즉시 실행 함수 표현식)의 주된 목적은 무엇인가요?", options: ["즉시 실행과 스코프 격리", "코드 압축", "비동기 처리", "없음"], answer: "즉시 실행과 스코프 격리" },
      { question: "자바스크립트 문법에서 Function.prototype.bind() 메서드의 주 역할은 무엇인가요?", options: ["함수의 this 값을 고정", "함수 복제", "메모리 최적화", "없음"], answer: "함수의 this 값을 고정" },
      { question: "자바스크립트 문법에서 옵저버 패턴을 구현할 때 주의해야 할 사항은 무엇인가요?", options: ["메모리 누수, 동기화 문제, 성능 저하", "코드 복잡성만", "네임스페이스 충돌", "없음"], answer: "메모리 누수, 동기화 문제, 성능 저하" },
      { question: "자바스크립트 문법에서 Map과 Object의 차이점은 무엇인가요?", options: ["키의 타입 제한, 순서 보장, 성능", "메모리 사용량", "함수 지원", "없음"], answer: "키의 타입 제한, 순서 보장, 성능" },
      { question: "자바스크립트 문법에서 WeakMap의 주요 특징은 무엇인가요?", options: ["키로 객체만 사용, 가비지 컬렉션 대상, 메모리 누수 방지", "키 제한 없음", "순서 보장", "없음"], answer: "키로 객체만 사용, 가비지 컬렉션 대상, 메모리 누수 방지" },
      { question: "자바스크립트 문법에서 Reflect.apply() 메서드의 역할은 무엇인가요?", options: ["함수를 특정 this와 인자로 호출", "객체 복사", "에러 처리", "없음"], answer: "함수를 특정 this와 인자로 호출" },
      { question: "자바스크립트 문법에서 비동기 이터레이터의 주요 장점은 무엇인가요?", options: ["비동기 스트림 처리", "동기 코드 실행", "메모리 절약", "없음"], answer: "비동기 스트림 처리" },
      { question: "자바스크립트 문법에서 Symbol.iterator의 주된 역할은 무엇인가요?", options: ["이터러블 프로토콜 구현", "함수 실행", "객체 복제", "없음"], answer: "이터러블 프로토콜 구현" },
      { question: "자바스크립트 문법에서 모듈 번들러(예: Webpack)의 주요 기능은 무엇인가요?", options: ["모듈 결합 및 최적화", "비동기 처리", "UI 렌더링", "없음"], answer: "모듈 결합 및 최적화" },
      { question: "자바스크립트 문법에서 Tail Call 최적화는 무엇을 개선하나요?", options: ["재귀 함수의 성능", "메모리 사용", "동기화", "없음"], answer: "재귀 함수의 성능" },
      { question: "자바스크립트 문법에서 import와 require의 차이점은 무엇인가요?", options: ["ES6 모듈과 CommonJS 모듈", "동기와 비동기", "파일 경로 처리", "없음"], answer: "ES6 모듈과 CommonJS 모듈" },
      { question: "자바스크립트 문법에서 Error 객체의 주요 프로퍼티는 무엇인가요?", options: ["name, message, stack", "type, value, code", "error, info, trace", "없음"], answer: "name, message, stack" },
      { question: "자바스크립트 문법에서 프로미스 체이닝의 주요 장점은 무엇인가요?", options: ["비동기 작업 순서 제어", "동시 실행", "메모리 최적화", "없음"], answer: "비동기 작업 순서 제어" },
      { question: "자바스크립트 문법에서 Optional Chaining 연산자와 Nullish 병합 연산자의 차이는 무엇인가요?", options: ["동작 방식, 사용 목적, 문법", "하나만 해당", "둘 다 사용하지 않음", "없음"], answer: "동작 방식, 사용 목적, 문법" },
      { question: "알고리즘에서 분할 정복 전략의 핵심 아이디어는 무엇인가요?", options: ["문제를 더 작은 문제로 분할하여 해결", "문제를 순차적으로 처리", "메모이제이션 사용", "없음"], answer: "문제를 더 작은 문제로 분할하여 해결" },
      { question: "동적 프로그래밍에서 최적 부분 구조의 의미는 무엇인가요?", options: ["문제의 최적 해결책이 부분 문제의 최적 해결책으로 구성됨", "문제가 반복적임", "문제가 분할됨", "없음"], answer: "문제의 최적 해결책이 부분 문제의 최적 해결책으로 구성됨" },
      { question: "NP-완전 문제의 주요 특징은 무엇인가요?", options: ["모든 NP 문제로 다항 시간 환원 가능", "결정 문제임", "해결하기 어려움", "모두 해당"], answer: "모두 해당" },
      { question: "그래프 이론에서 다익스트라 알고리즘의 주요 용도는 무엇인가요?", options: ["최단 경로 탐색", "최소 신장 트리", "네트워크 플로우", "없음"], answer: "최단 경로 탐색" },
      { question: "정렬 알고리즘 중 퀵 정렬의 평균 시간 복잡도는 얼마인가요?", options: ["O(n log n)", "O(n²)", "O(n)", "O(log n)"], answer: "O(n log n)" },
      { question: "동시성 제어에서 교착 상태(Deadlock)가 발생하는 주요 원인은 무엇인가요?", options: ["상호 배제, 점유 대기, 비선점, 순환 대기", "메모리 부족", "스레드 수 과다", "없음"], answer: "상호 배제, 점유 대기, 비선점, 순환 대기" },
      { question: "데이터베이스에서 트랜잭션의 ACID 특성 중 Isolation의 의미는 무엇인가요?", options: ["동시에 실행된 트랜잭션 간 간섭 없음", "모든 트랜잭션이 성공 또는 실패", "데이터 일관성 유지", "없음"], answer: "동시에 실행된 트랜잭션 간 간섭 없음" },
      { question: "컴퓨터 네트워크에서 TCP와 UDP의 주요 차이점은 무엇인가요?", options: ["연결 지향 vs 비연결 지향, 속도, 신뢰성", "속도만 다름", "프로토콜 번호", "없음"], answer: "연결 지향 vs 비연결 지향, 속도, 신뢰성" },
      { question: "메모리 관리에서 가비지 컬렉션의 주된 목적은 무엇인가요?", options: ["사용하지 않는 객체 자동 제거", "메모리 할당", "프로세스 스케줄링", "없음"], answer: "사용하지 않는 객체 자동 제거" },
      { question: "컴퓨터 구조에서 파이프라이닝의 주요 장점은 무엇인가요?", options: ["명령어 처리 속도 향상", "메모리 절약", "동기화 제공", "없음"], answer: "명령어 처리 속도 향상" },
      { question: "알고리즘 설계에서 그리디 알고리즘의 특징은 무엇인가요?", options: ["매 단계마다 최적 선택", "전체 최적 해 보장", "동적 프로그래밍과 유사", "없음"], answer: "매 단계마다 최적 선택" },
      { question: "암호학에서 대칭 키 암호화의 단점은 무엇인가요?", options: ["키 분배 문제", "암호화 속도", "복잡한 알고리즘", "없음"], answer: "키 분배 문제" },
      { question: "데이터베이스에서 인덱스의 주요 역할은 무엇인가요?", options: ["데이터 검색 속도 향상", "데이터 보안 강화", "데이터 저장 공간 절약", "없음"], answer: "데이터 검색 속도 향상" },
      { question: "튜링 머신이 중요한 이유는 무엇인가요?", options: ["계산 가능성의 한계를 정의", "실제 컴퓨터 구조", "네트워크 프로토콜", "없음"], answer: "계산 가능성의 한계를 정의" },
      { question: "자연어 처리에서 토큰화의 역할은 무엇인가요?", options: ["텍스트를 단어 단위로 분할", "텍스트 요약", "텍스트 번역", "없음"], answer: "텍스트를 단어 단위로 분할" },
      { question: "컴퓨터 그래픽스에서 렌더링의 주된 목적은 무엇인가요?", options: ["이미지 생성", "데이터 압축", "네트워크 전송", "없음"], answer: "이미지 생성" },
      { question: "머신러닝에서 과적합(Overfitting)을 방지하기 위한 일반적인 방법은 무엇인가요?", options: ["정규화, 교차 검증, 데이터 증강, 하이퍼파라미터 튜닝", "데이터 증강만", "모델 단순화만", "없음"], answer: "정규화, 교차 검증, 데이터 증강, 하이퍼파라미터 튜닝" },
      { question: "분산 처리에서 분산 시스템의 주요 이점은 무엇인가요?", options: ["처리 속도 향상, 데이터 처리량 증가, 시스템 확장성", "단순 분산", "메모리 최적화", "없음"], answer: "처리 속도 향상, 데이터 처리량 증가, 시스템 확장성" },
      { question: "네트워크 보안에서 방화벽의 주된 역할은 무엇인가요?", options: ["불법 접근 차단", "데이터 암호화", "네트워크 모니터링", "없음"], answer: "불법 접근 차단" },
      { question: "운영체제에서 컨텍스트 스위칭의 단점은 무엇인가요?", options: ["오버헤드 증가", "메모리 누수", "데이터 손실", "없음"], answer: "오버헤드 증가" },
      { question: "네트워크 라우팅 프로토콜의 예로 옳은 것은 무엇인가요?", options: ["OSPF, BGP", "HTTP, FTP", "TCP, UDP", "없음"], answer: "OSPF, BGP" },
      { question: "공개 키 암호화의 주요 장점은 무엇인가요?", options: ["키 분배 문제 해결", "빠른 암호화", "데이터 압축", "없음"], answer: "키 분배 문제 해결" },
      { question: "동적 계획법과 그리디 알고리즘의 차이점은 무엇인가요?", options: ["최적 부분 구조와 선택 기준", "시간 복잡도", "공간 복잡도", "없음"], answer: "최적 부분 구조와 선택 기준" },
      { question: "NP-하드 문제의 특징은 무엇인가요?", options: ["NP 문제보다 어려움, 결정 문제가 아님, 다항 시간 환원 불가능", "단순 어려움", "결정 문제임", "없음"], answer: "NP 문제보다 어려움, 결정 문제가 아님, 다항 시간 환원 불가능" },
      { question: "SSL/TLS 프로토콜의 주된 역할은 무엇인가요?", options: ["데이터 암호화와 인증", "속도 향상", "네트워크 연결", "없음"], answer: "데이터 암호화와 인증" },
      { question: "운영체제에서 페이지 교체 알고리즘의 예로 옳은 것은 무엇인가요?", options: ["LRU, FIFO", "DFS, BFS", "Quick Sort, Merge Sort", "없음"], answer: "LRU, FIFO" },
      { question: "병합 정렬의 주요 특징은 무엇인가요?", options: ["안정 정렬, O(n log n)", "불안정 정렬, O(n²)", "빠른 정렬, O(n)", "없음"], answer: "안정 정렬, O(n log n)" },
      { question: "캐시 메모리의 주요 역할은 무엇인가요?", options: ["데이터 접근 속도 향상", "메모리 확장", "데이터 암호화", "없음"], answer: "데이터 접근 속도 향상" },
      { question: "데이터베이스 정규화의 주된 목적은 무엇인가요?", options: ["데이터 중복 제거 및 무결성 유지", "데이터 압축", "검색 속도 향상", "없음"], answer: "데이터 중복 제거 및 무결성 유지" },
      { question: "분산 시스템의 주요 도전 과제는 무엇인가요?", options: ["노드 간 통신 지연, 데이터 일관성 유지, 장애 허용성", "단순 확장", "메모리 최적화", "없음"], answer: "노드 간 통신 지연, 데이터 일관성 유지, 장애 허용성" },
      { question: "컴퓨터 과학에서 알고리즘이란 무엇인가요?", options: ["문제 해결을 위한 단계적 절차", "프로그램 코드", "데이터베이스", "없음"], answer: "문제 해결을 위한 단계적 절차" },
      { question: "컴퓨터 과학에서 빅오 표기법은 무엇을 설명하나요?", options: ["알고리즘의 시간 복잡도", "메모리 사용량", "코드 길이", "없음"], answer: "알고리즘의 시간 복잡도" },
      { question: "컴퓨터 과학에서 자료구조란 무엇인가요?", options: ["데이터를 효율적으로 저장하고 관리하는 방법", "알고리즘", "프로그램", "없음"], answer: "데이터를 효율적으로 저장하고 관리하는 방법" },
      { question: "컴퓨터 과학에서 스택 자료구조의 특징은 무엇인가요?", options: ["LIFO (Last In, First Out)", "FIFO (First In, First Out)", "무작위 접근", "없음"], answer: "LIFO (Last In, First Out)" },
      { question: "컴퓨터 과학에서 큐 자료구조의 특징은 무엇인가요?", options: ["FIFO (First In, First Out)", "LIFO (Last In, First Out)", "순차 정렬", "없음"], answer: "FIFO (First In, First Out)" },
      { question: "컴퓨터 과학에서 이진 탐색을 사용하기 위한 전제 조건은 무엇인가요?", options: ["정렬된 배열", "무작위 배열", "중복된 값", "없음"], answer: "정렬된 배열" },
      { question: "컴퓨터 과학에서 재귀 함수란 무엇인가요?", options: ["자기 자신을 호출하는 함수", "반복문", "조건문", "없음"], answer: "자기 자신을 호출하는 함수" },
      { question: "컴퓨터 과학에서 해시 테이블은 데이터를 어떤 방식으로 저장하나요?", options: ["해시 함수를 이용한 키-값 쌍", "순차 배열", "연결 리스트", "없음"], answer: "해시 함수를 이용한 키-값 쌍" },
      { question: "컴퓨터 과학에서 네트워크 프로토콜이란 무엇인가요?", options: ["데이터 통신 규칙 집합", "데이터 저장 방식", "프로그래밍 언어", "없음"], answer: "데이터 통신 규칙 집합" },
      { question: "컴퓨터 과학에서 운영체제의 주요 기능 중 하나는 무엇인가요?", options: ["자원 관리", "프로그래밍", "데이터베이스 관리", "없음"], answer: "자원 관리" },
      { question: "컴퓨터 과학에서 컴파일러의 역할은 무엇인가요?", options: ["소스 코드를 기계어로 변환함", "코드를 실행함", "메모리를 관리함", "없음"], answer: "소스 코드를 기계어로 변환함" },
      { question: "컴퓨터 과학에서 인터프리터의 역할은 무엇인가요?", options: ["소스 코드를 한 줄씩 실행함", "전체 코드를 컴파일함", "메모리를 할당함", "없음"], answer: "소스 코드를 한 줄씩 실행함" },
      { question: "컴퓨터 과학에서 데이터베이스 관리 시스템(DBMS)의 주요 목적은 무엇인가요?", options: ["데이터 저장, 검색, 관리", "코드 실행", "네트워크 연결", "없음"], answer: "데이터 저장, 검색, 관리" },
      { question: "컴퓨터 과학에서 인덱스는 데이터베이스에서 주로 무엇을 향상시키나요?", options: ["검색 속도", "데이터 무결성", "메모리 사용", "없음"], answer: "검색 속도" },
      { question: "컴퓨터 과학에서 캐시 메모리의 역할은 무엇인가요?", options: ["데이터 접근 속도 향상", "데이터 저장", "코드 실행", "없음"], answer: "데이터 접근 속도 향상" },
      { question: "컴퓨터 과학에서 소켓 프로그래밍은 주로 무엇에 사용되나요?", options: ["네트워크 통신", "파일 입출력", "데이터베이스 연결", "없음"], answer: "네트워크 통신" },
      { question: "컴퓨터 과학에서 암호화란 무엇을 위해 사용되나요?", options: ["데이터 보호", "데이터 압축", "데이터 정렬", "없음"], answer: "데이터 보호" },
      { question: "컴퓨터 과학에서 알고리즘의 안정성이란 무엇을 의미하나요?", options: ["동일한 값의 순서를 유지함", "알고리즘 속도", "메모리 사용", "없음"], answer: "동일한 값의 순서를 유지함" },
      { question: "컴퓨터 과학에서 그래프에서 정점과 간선은 어떤 관계에 있나요?", options: ["정점은 간선으로 연결됨", "정점과 간선은 독립적임", "간선이 정점을 포함함", "없음"], answer: "정점은 간선으로 연결됨" },
      { question: "컴퓨터 과학에서 애자일(Agile) 개발 방법론의 주요 특징은 무엇인가요?", options: ["유연한 계획과 반복적 개발", "고정된 계획", "단일 단계 개발", "없음"], answer: "유연한 계획과 반복적 개발" },
      { question: "컴퓨터 과학에서 버전 관리 시스템으로 널리 사용되는 도구는 무엇인가요?", options: ["Git", "SVN", "Mercurial", "모두 해당"], answer: "Git" },
      { question: "컴퓨터 과학에서 컴퓨터 네트워크의 기본 구조 중 하나는 무엇인가요?", options: ["클라이언트-서버", "피어 투 피어", "모두 해당", "없음"], answer: "모두 해당" },
      { question: "컴퓨터 과학에서 소프트웨어의 버그란 무엇을 의미하나요?", options: ["오류나 결함", "코드 최적화", "메모리 할당", "없음"], answer: "오류나 결함" },
      { question: "컴퓨터 과학에서 알고리즘 효율성을 측정할 때 주로 사용하는 기준은 무엇인가요?", options: ["시간 복잡도", "코드 길이", "메모리 사용", "없음"], answer: "시간 복잡도" },
      { question: "컴퓨터 과학에서 데이터 압축의 주된 목적은 무엇인가요?", options: ["저장 공간 절약", "데이터 보안", "네트워크 속도 향상", "없음"], answer: "저장 공간 절약" },
      { question: "컴퓨터 과학에서 이진 트리의 특징 중 하나는 무엇인가요?", options: ["각 노드가 최대 두 개의 자식을 가짐", "모든 노드가 자식을 가짐", "노드 순서가 없음", "없음"], answer: "각 노드가 최대 두 개의 자식을 가짐" },
      { question: "컴퓨터 과학에서 소프트웨어 개발 생명주기(SDLC)의 첫 단계는 무엇인가요?", options: ["요구사항 분석", "코드 작성", "테스트 수행", "배포"], answer: "요구사항 분석" },
      { question: "컴퓨터 과학에서 중앙 처리 장치(CPU)의 주 역할은 무엇인가요?", options: ["명령어 처리", "데이터 저장", "그래픽 처리", "없음"], answer: "명령어 처리" },
      { question: "컴퓨터 과학에서 캐시 메모리는 일반적으로 CPU와 주 메모리 사이에 위치합니다. 이 설명은 옳은가요?", options: ["옳다", "그렇지 않다"], answer: "옳다" },
      { question: "컴퓨터 과학에서 클라우드 컴퓨팅의 주요 특징은 무엇인가요?", options: ["유연한 자원 제공과 비용 효율성", "고정된 자원 제공", "로컬 컴퓨팅", "없음"], answer: "유연한 자원 제공과 비용 효율성" },
    ];

    function createQuizCard() {
      const card = document.createElement('div');
      card.className = 'card glass-card mb-3 quiz-card';
      card.quizCount = 0; // 정답 횟수를 추적 (최대 3회)

      const cardBody = document.createElement('div');
      cardBody.className = 'card-body';
      card.appendChild(cardBody);

      function loadQuiz() {
        cardBody.innerHTML = '';
        const quiz = quizQuestionsAll[Math.floor(Math.random() * quizQuestionsAll.length)];
        cardBody.innerHTML = `
          <h5 class="card-title">퀴즈 타임!</h5>
          <p class="card-text quiz-question">${quiz.question}</p>
          <div class="quiz-options mb-3"></div>
          <p class="quiz-result text-info"></p>
        `;
        const optionsDiv = cardBody.querySelector('.quiz-options');
        const resultEl = cardBody.querySelector('.quiz-result');
        quiz.options.forEach(function(option) {
          const btn = document.createElement('button');
          btn.className = 'btn btn-outline-primary quiz-option';
          btn.textContent = option;
          btn.addEventListener('click', async function() {
            if (option === quiz.answer) {
              // 정답일 경우
              optionsDiv.querySelectorAll('button').forEach(function(b) { b.disabled = true; });
              await awardQuizPoint();
              card.quizCount++;
              if (card.quizCount < 1) {
                // "다음" 버튼을 결과 문구 오른쪽에 인라인으로 추가
                resultEl.innerHTML = '정답입니다! 포인트 1점 획득! ';
                var nextBtn = document.createElement('button');
                nextBtn.className = 'btn btn-primary btn-sm';
                nextBtn.textContent = '다음';
                nextBtn.style.marginLeft = '10px';
                nextBtn.addEventListener('click', function() { loadQuiz(); });
                resultEl.appendChild(nextBtn);
              } else {
                // 3문제 모두 정답 시 성취감 있는 메시지 표시
                resultEl.textContent = '정답입니다! 포인트 1점 획득!';
              }
            } else {
              resultEl.textContent = '오답입니다. 다시 시도해보세요!';
            }
          });
          optionsDiv.appendChild(btn);
        });
      }

      loadQuiz();
      return card;
    }

    /********************************
     * 날짜/시간 포맷 함수
     ********************************/
    function formatDateTime(timestamp) {
      if (!timestamp || !timestamp.seconds) return '';
      const date = new Date(timestamp.seconds * 1000);
      let year = date.getFullYear(), month = date.getMonth() + 1, day = date.getDate();
      let hours = date.getHours(), minutes = date.getMinutes(), seconds = date.getSeconds();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12; hours = hours === 0 ? 12 : hours;
      minutes = minutes.toString().padStart(2, '0'); seconds = seconds.toString().padStart(2, '0');
      return `${year}.${month}.${day}, ${hours}:${minutes}:${seconds} ${ampm}`;
    }
    function formatDateForToast(date) {
      let year = date.getFullYear(), month = date.getMonth() + 1, day = date.getDate();
      let hours = date.getHours(), minutes = date.getMinutes(), seconds = date.getSeconds();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12; hours = hours === 0 ? 12 : hours;
      minutes = minutes.toString().padStart(2, '0'); seconds = seconds.toString().padStart(2, '0');
      return `${year}.${month}.${day}, ${hours}:${minutes}:${seconds} ${ampm}`;
    }

    /********************************
     * Toast 함수
     ********************************/
    function showToast(message, title = '알림') {
      const toastEl = document.getElementById('liveToast');
      const toastTitle = document.getElementById('toastTitle');
      const toastMessage = document.getElementById('toastMessage');
      const toastTime = document.getElementById('toastTime');
      toastTitle.textContent = title;
      toastMessage.textContent = message;
      toastTime.textContent = formatDateForToast(new Date());
      const bsToast = new bootstrap.Toast(toastEl);
      bsToast.show();
    }

    /********************************
     * DOM 요소 참조
     ********************************/
    const authLoadingBtn = document.getElementById('authLoadingBtn');
    const loginBtn = document.getElementById('loginBtn');
    const signupBtn = document.getElementById('signupBtn');
    // 기존 logoutBtn는 제거하고 드롭다운에서 처리함
    const togglePostFormBtn = document.getElementById('togglePostFormBtn');
    const showRankBtn = document.getElementById('showRankBtn');
    const postCard = document.getElementById('postCard');
    const savePostBtn = document.getElementById('savePostBtn');
    const postList = document.getElementById('postList');
    const signupForm = document.getElementById('signupForm');
    const signupEmail = document.getElementById('signupEmail');
    const signupPassword = document.getElementById('signupPassword');
    const signupNickname = document.getElementById('signupNickname');
    const loginForm = document.getElementById('loginForm');
    const loginEmail = document.getElementById('loginEmail');
    const loginPassword = document.getElementById('loginPassword');
    const resetPasswordBtn = document.getElementById('resetPasswordBtn');
    const postTitle = document.getElementById('postTitle');
    const editModalEl = document.getElementById('editModal');
    const editModal = new bootstrap.Modal(editModalEl);
    const editPostId = document.getElementById('editPostId');
    const editTitle = document.getElementById('editTitle');
    const updatePostBtn = document.getElementById('updatePostBtn');
    const deleteCommentModalEl = document.getElementById('deleteCommentModal');
    const deleteCommentModal = new bootstrap.Modal(deleteCommentModalEl);
    const deleteCommentPostId = document.getElementById('deleteCommentPostId');
    const deleteCommentId = document.getElementById('deleteCommentId');
    const confirmDeleteCommentBtn = document.getElementById('confirmDeleteCommentBtn');
    const rankModalEl = document.getElementById('rankModal');
    const myScoreEl = document.getElementById('myScore');
    const myRankEl = document.getElementById('myRank');
    const deleteAccountBtn = document.getElementById('deleteAccountBtn');
    const noticeContainer = document.getElementById('noticeContainer');

    /********************************
     * 전역 상태 변수
     ********************************/
    let currentNickname = null;
    let currentScore = 0;
    let commentUnsubscribers = {};

    function clearPostList() {
      Object.values(commentUnsubscribers).forEach(unsub => unsub());
      commentUnsubscribers = {};
      postList.innerHTML = '';
      lastVisible = null;
    }

    /********************************
     * 계급(Rank) 계산 및 마법 관련 함수
     ********************************/
    function getRankByScore(score) {
      if (score >= 50000) return { name: '이터널', icon: '🌌' };
      else if (score >= 25000) return { name: '레전드', icon: '👑' };
      else if (score >= 10000) return { name: '마스터', icon: '🏆' };
      else if (score >= 5000) return { name: '다이아몬드', icon: '💎' };
      else if (score >= 1000) return { name: '플래티넘', icon: '🛡️' };
      else if (score >= 500) return { name: '골드', icon: '🥇' };
      else if (score >= 100) return { name: '실버', icon: '🥈' };
      else return { name: '브론즈', icon: '🥉' };
    }
    function getAvailableMagicTypes(rankName) {
      switch(rankName) {
        case '브론즈': return ['magic-basic'];
        case '실버': return ['magic-basic', 'magic-shimmer'];
        case '골드': return ['magic-basic', 'magic-shimmer', 'magic-blessing'];
        case '플래티넘': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse'];
        case '다이아몬드': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse', 'magic-font'];
        case '마스터': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse', 'magic-font', 'magic-title'];
        case '레전드': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse', 'magic-font', 'magic-title', 'magic-rainbow'];
        case '이터널': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse', 'magic-font', 'magic-title', 'magic-rainbow', 'magic-ultimate'];
        default: return ['magic-basic'];
      }
    }
    const magicDisplayNames = {
      'magic-basic': '기본 마법',
      'magic-shimmer': '반짝이는 마법',
      'magic-blessing': '축복의 마법',
      'magic-curse': '저주의 마법',
      'magic-font': '글꼴 변경 마법',
      'magic-title': '글자 뒤집기 마법',
      'magic-rainbow': '무지개 마법',
      'magic-ultimate': '궁극의 마법'
    };
    function decodeHtml(html) {
      const txt = document.createElement("textarea");
      txt.innerHTML = html;
      return txt.value;
    }
    function parseTimeParameter(timeStr) {
      let seconds = 0;
      const hMatch = timeStr.match(/(\d+)h/);
      if (hMatch) seconds += parseInt(hMatch[1], 10) * 3600;
      const mMatch = timeStr.match(/(\d+)m/);
      if (mMatch) seconds += parseInt(mMatch[1], 10) * 60;
      const sMatch = timeStr.match(/(\d+)s/);
      if (sMatch) seconds += parseInt(sMatch[1], 10);
      if (!hMatch && !mMatch && !sMatch && /^\d+$/.test(timeStr)) seconds = parseInt(timeStr, 10);
      return seconds;
    }
    function convertYouTubeLinks(text) {
      // 이미 iframe 태그가 있다면 변환하지 않고 원본 반환
      if (/(&lt;iframe|<iframe)/i.test(text)) return text;

      return text.replace(
        /(?:https?:\/\/)?(?:www\.)?(?:(?:youtu\.be\/)|(?:youtube\.com\/(?:watch\?v=|shorts\/)))([A-Za-z0-9_-]{11})([^<\s]*)/g,
        (match, videoId, params) => {
          let startParam = '';
          if (params) {
            // HTML 이스케이프된 &amp;를 실제 &로 복원하고, 앞부분의 ? 또는 &를 제거
            const queryString = params.replace(/&amp;/g, '&').replace(/^[\?&]/, '');
            const searchParams = new URLSearchParams(queryString);
            const t = searchParams.get('t');
            if (t) {
              const seconds = parseTimeParameter(t);
              startParam = `?start=${seconds}`;
            }
          }
          return `<div class="video-responsive">
                    <iframe width="560" height="315" 
                            src="https://www.youtube.com/embed/${videoId}${startParam}" 
                            frameborder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            allowfullscreen>
                    </iframe>
                  </div>`;
        }
      );
    }
    function convertLinks(text) {
      return text.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>');
    }

    /********************************
     * 공지사항 로드
     ********************************/
    async function fetchActiveNotices() {
      const now = new Date();
      const q = query(
        collection(db, 'notices'),
        where('startDate', '<=', now),
        where('endDate', '>=', now),
        orderBy('startDate', 'desc')
      );
      let celebrating = false;
      const snapshot = await getDocs(q);
      noticeContainer.innerHTML = '';
      for (const docSnap of snapshot.docs) {
        const data = docSnap.data();
        const bannerEl = document.createElement('div');
        bannerEl.classList.add('notice-banner');
        bannerEl.textContent = data.content;
        if (data.content.includes('🎉')) {
          bannerEl.addEventListener('click', launchFireworks);
          celebrating = true;
        }
        noticeContainer.appendChild(bannerEl);
      }
      if (celebrating) launchFireworks();
    }

    /********************************
     * 회원가입, 로그인, 비밀번호 초기화, 로그아웃
     ********************************/
    signupForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const emailVal = signupEmail.value.trim();
      const pwVal = signupPassword.value.trim();
      const nickVal = signupNickname.value.trim();
      if (!emailVal || !pwVal || !nickVal) {
        showToast('모든 항목을 입력하세요.', '회원가입 실패');
        return;
      }
      try {
        const userCredential = await createUserWithEmailAndPassword(auth, emailVal, pwVal);
        const user = userCredential.user;
        await setDoc(doc(db, 'users', user.uid), {
          nickname: nickVal,
          score: 0,
          createdAt: serverTimestamp()
        });
        showToast('회원가입 성공!', '회원가입');
        bootstrap.Modal.getInstance(document.getElementById('signupModal')).hide();
        location.reload();
      } catch (err) {
        showToast(err.message, '회원가입 실패');
      }
    });
    loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const emailVal = loginEmail.value.trim();
      const pwVal = loginPassword.value.trim();
      if (!emailVal || !pwVal) {
        showToast('이메일/비밀번호를 입력하세요.', '로그인 실패');
        return;
      }
      try {
        await signInWithEmailAndPassword(auth, emailVal, pwVal);
        showToast('로그인 성공!', '로그인');
        bootstrap.Modal.getInstance(document.getElementById('loginModal')).hide();
        location.reload();
      } catch (err) {
        showToast(err.message, '로그인 실패');
      }
    });
    resetPasswordBtn.addEventListener('click', async () => {
      const emailVal = loginEmail.value.trim();
      if (!emailVal) {
        showToast('이메일을 입력하세요.', '오류');
        return;
      }
      if (confirm(`${emailVal}로 비밀번호 초기화 메일을 보내시겠습니까?`)) {
        try {
          await sendPasswordResetEmail(auth, emailVal);
          showToast('비밀번호 초기화 메일을 보냈습니다.', '비밀번호 초기화');
        } catch (err) {
          showToast(err.message, '오류');
        }
      }
    });
    // 기존 logoutBtn 이벤트 리스너는 제거하고 아래에서 드롭다운 로그아웃 이벤트를 추가합니다.
    onAuthStateChanged(auth, async (user) => {
      authLoadingBtn.classList.add('d-none');
      if (user) {
        loginBtn.classList.add('d-none');
        signupBtn.classList.add('d-none');
        document.getElementById('userDropdown').classList.remove('d-none');
        togglePostFormBtn.classList.remove('d-none');
        const userData = await fetchUserNicknameAndScore(user.uid);
        currentNickname = userData.nickname;
        currentScore = userData.score;
        const rankInfo = getRankByScore(currentScore);
        document.getElementById('userDropdownMenuButton').innerText = `${currentNickname} ${rankInfo.icon}`;
      } else {
        loginBtn.classList.remove('d-none');
        signupBtn.classList.remove('d-none');
        document.getElementById('userDropdown').classList.add('d-none');
        togglePostFormBtn.classList.add('d-none');
        postCard.classList.add('d-none');
        currentNickname = null;
        currentScore = 0;
      }
      const commentForms = document.querySelectorAll('[id^="commentForm-"]');
      if (user) {
        commentForms.forEach(form => form.classList.remove('d-none'));
      } else {
        commentForms.forEach(form => form.classList.add('d-none'));
      }
    });
    // 드롭다운의 로그아웃 버튼 이벤트 처리
    document.getElementById('logoutBtnDropdown').addEventListener('click', async () => {
      try {
        await signOut(auth);
        showToast('로그아웃 완료', '로그아웃');
        location.reload();
      } catch (error) {
        showToast(error.message, '로그아웃 실패');
      }
    });
    togglePostFormBtn.addEventListener('click', () => {
      postCard.classList.toggle('d-none');
      if (!postCard.classList.contains('d-none')) {
        postTitle.focus();
      }
    });

    rankModalEl.addEventListener('show.bs.modal', async () => {
      const futureMagicListEl = document.getElementById('futureMagicList');
      if (!auth.currentUser) {
        myScoreEl.textContent = '(로그인 필요)';
        myRankEl.textContent = '-';
      } else {
        const snap = await getDoc(doc(db, 'users', auth.currentUser.uid));
        if (snap.exists()) {
          const data = snap.data();
          userCache[auth.currentUser.uid] = data;
          currentScore = data.score || 0;
          currentNickname = data.nickname || null;
        }
        myScoreEl.textContent = `${currentScore}점`;
        const rankInfo = getRankByScore(currentScore);
        myRankEl.textContent = `${rankInfo.name} ${rankInfo.icon}`;
      }
      const lastMagicTypes = getAvailableMagicTypes('이터널');
      const rankMagicMapping = [
        { rank: '브론즈', icon: '🥉', range: '0~99' },
        { rank: '실버', icon: '🥈', range: '100~499' },
        { rank: '골드', icon: '🥇', range: '500~999' },
        { rank: '플래티넘', icon: '🛡️', range: '1,000~4,999' },
        { rank: '다이아몬드', icon: '💎', range: '5,000~9,999' },
        { rank: '마스터', icon: '🏆', range: '10,000~24,999' },
        { rank: '레전드', icon: '👑', range: '25,000~49,999' },
        { rank: '이터널', icon: '🌌', range: '50,000+' }
      ];
      let futureMagicHTML = '';
      rankMagicMapping.forEach((mapping, i) => {
        mapping.magic = [ lastMagicTypes[i] ];
        const magicList = mapping.magic.map(type => magicDisplayNames[type] || type).join(', ');
        futureMagicHTML += `<li>${mapping.icon} ${mapping.rank} (${mapping.range}): ${magicList}</li>`;
      });
      futureMagicListEl.innerHTML = futureMagicHTML;
    });

    /********************************
     * 글 작성 (DOMPurify 및 유튜브 임베디드 적용)
     ********************************/
    savePostBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      if (!currentNickname) {
        showToast('닉네임을 불러오지 못했습니다.', '오류');
        return;
      }
      const titleVal = DOMPurify.sanitize(postTitle.value.trim(), { ALLOWED_TAGS: [] });
      const contentVal = createEditor ? createEditor.getHTML() : '';
      if (!titleVal) {
        showToast('제목을 입력하세요.', '오류');
        return;
      }
      if (!contentVal.trim()) {
        showToast('내용을 입력하세요.', '오류');
        return;
      }
      try {
        await runTransaction(db, async (transaction) => {
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          const newPostRef = doc(collection(db, 'posts'));
          transaction.set(newPostRef, {
            uid: user.uid,
            nickname: currentNickname,
            title: titleVal,
            content: contentVal,
            createdAt: serverTimestamp(),
            likes: [],
            dislikes: []
          });
          transaction.update(userRef, { score: oldScore + 50 });
        });
        showToast('글이 등록되었습니다.', '글 작성');
        postTitle.value = '';
        createEditor.setHTML('');
        postCard.classList.add('d-none');
        clearPostList();
        await loadMorePosts();
        const userData = await fetchUserNicknameAndScore(user.uid);
        currentScore = userData.score;
      } catch (err) {
        showToast(err.message, '글 작성 실패');
      }
    });

    /********************************
     * 글 수정 및 삭제
     ********************************/
    async function openEditModal(postDoc) {
      editPostId.value = postDoc.id;
      editTitle.value = postDoc.data().title;
      if (editEditor) editEditor.setHTML(postDoc.data().content);
      editModal.show();
    }
    updatePostBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const docId = editPostId.value;
      const newTitle = editTitle.value.trim();
      const newContent = editEditor ? editEditor.getHTML() : '';
      if (!newTitle || !newContent.trim()) {
        showToast('제목과 내용을 입력하세요.', '오류');
        return;
      }
      try {
        const postRef = doc(db, 'posts', docId);
        const postSnap = await getDoc(postRef);
        if (!postSnap.exists()) {
          showToast('존재하지 않는 글입니다.', '오류');
          return;
        }
        if (postSnap.data().uid !== user.uid) {
          showToast('본인 글만 수정할 수 있습니다.', '오류');
          return;
        }
        await updateDoc(postRef, { title: newTitle, content: newContent });
        showToast('글이 수정되었습니다.', '성공');
        editModal.hide();
        clearPostList();
        await loadMorePosts();
      } catch (err) {
        showToast(err.message, '수정 실패');
      }
    });
    async function deletePost(postDoc) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const postData = postDoc.data();
      if (postData.uid !== user.uid) {
        showToast('본인 글만 삭제할 수 있습니다.', '오류');
        return;
      }
      if (!confirm('이 글을 삭제하시겠습니까?')) return;
      try {
        await deleteDoc(postDoc.ref);
        showToast('글이 삭제되었습니다.', '삭제');
        clearPostList();
        await loadMorePosts();
      } catch (err) {
        showToast(err.message, '삭제 실패');
      }
    }

    /********************************
     * 댓글 등록 (부모 댓글 ID 선택적)
     ********************************/
    async function addComment(postId, content, parentCommentId = null) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const sanitizedContent = DOMPurify.sanitize(content, { ALLOWED_TAGS: [] });
      if (!sanitizedContent.trim()) {
        showToast('댓글 내용을 입력하세요.', '오류');
        return;
      }
      try {
        await runTransaction(db, async (transaction) => {
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          const cmtRef = doc(collection(db, 'posts', postId, 'comments'));
          transaction.set(cmtRef, {
            uid: user.uid,
            nickname: currentNickname,
            content: sanitizedContent,
            createdAt: serverTimestamp(),
            parentCommentId: parentCommentId || null,
            likes: [],
            dislikes: []
          });
          transaction.update(userRef, { score: oldScore + 20 });
        });
        showToast('댓글이 등록되었습니다.', '댓글 작성');
      } catch (err) {
        showToast(err.message, '댓글 등록 실패');
      }
    }

    /********************************
     * 댓글 삭제
     ********************************/
    function openDeleteCommentModal(postId, commentId) {
      deleteCommentPostId.value = postId;
      deleteCommentId.value = commentId;
      deleteCommentModal.show();
    }
    confirmDeleteCommentBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const postId = deleteCommentPostId.value;
      const commentId = deleteCommentId.value;
      try {
        const commentRef = doc(db, 'posts', postId, 'comments', commentId);
        const commentSnap = await getDoc(commentRef);
        if (!commentSnap.exists()) {
          showToast('존재하지 않는 댓글입니다.', '오류');
          return;
        }
        if (commentSnap.data().uid !== user.uid) {
          showToast('본인 댓글만 삭제할 수 있습니다.', '오류');
          return;
        }
        await deleteDoc(commentRef);
        showToast('댓글이 삭제되었습니다.', '댓글 삭제');
        deleteCommentModal.hide();
      } catch (err) {
        showToast(err.message, '댓글 삭제 실패');
      }
    });

    /********************************
     * 댓글 렌더링 (계층구조 처리)
     ********************************/
     async function renderComments(postId, comments, containerEl) {
      containerEl.innerHTML = '';
      const header = document.getElementById(`commentHeader-${postId}`);
      if (comments.length === 0) {
        if (header) header.style.display = 'none';
      } else {
        if (header) header.style.display = '';
      }
      const commentMap = {};
      comments.forEach(c => {
        c.children = [];
        commentMap[c.commentId] = c;
      });
      const roots = [];
      comments.forEach(c => {
        if (c.parentCommentId && commentMap[c.parentCommentId]) {
          commentMap[c.parentCommentId].children.push(c);
        } else {
          roots.push(c);
        }
      });

      function isOnlyEmoji(text) {
        const trimmed = text.trim();
        // 정규표현식: 텍스트가 단일 이모지(필수적으로 FE0F 선택적 포함)만 포함하는지 검사
        const regex = /^(?:\p{Extended_Pictographic}(?:\uFE0F)?)$/u;
        return regex.test(trimmed);
      }

      function renderCommentNode(comment, indent = 0) {
        let rankIcon = '';
        let commentNickname = comment.nickname || '익명';
        const div = document.createElement('div');
        div.className = 'comment-item';
        // indent는 rem 단위로 적용되며, 최대 2rem까지만 들여쓰기합니다.
        div.style.marginLeft = indent + 'rem';

        const safeContent = DOMPurify.sanitize(comment.content ?? '', { ALLOWED_TAGS: [] });
        let finalContent;
        if (isOnlyEmoji(safeContent)) {
          finalContent = `<span class="emoji-large">${safeContent}</span>`;
        } else {
          finalContent = convertLinks(safeContent);
        }
        const dateStr = formatDateTime(comment.createdAt);

        // 최상위 댓글(indent가 0인 경우)에만 답글 버튼과 폼을 노출
        const replyButtonHtml = indent === 0
          ? `<button class="btn btn-sm btn-link" id="replyBtn-${postId}-${comment.commentId}">답글</button>`
          : '';
        const replyFormHtml = indent === 0
          ? `<div class="reply-form d-none" id="replyForm-${postId}-${comment.commentId}">
              <textarea class="form-control mb-2" rows="2" placeholder="댓글을 입력하세요" id="replyInput-${postId}-${comment.commentId}"></textarea>
              <button class="btn btn-secondary btn-sm" id="replySubmitBtn-${postId}-${comment.commentId}">댓글 달기</button>
            </div>`
          : '';

        div.innerHTML = `
          <div class="fw-bold">
            ${commentNickname} <span style="cursor:pointer;" id="commentRankIcon-${postId}-${comment.commentId}">${rankIcon}</span>
          </div>
          <div class="small text-muted mb-1">
            ${dateStr}
          </div>
          <div class="keep-line-breaks">${finalContent}</div>
          <div class="mt-1 d-flex align-items-center gap-2">
            <button class="btn btn-sm btn-outline-primary" id="commentLikeBtn-${postId}-${comment.commentId}">👍</button>
            <span id="commentLikeCount-${postId}-${comment.commentId}">${comment.likes ? comment.likes.length : 0}</span>
            <button class="btn btn-sm btn-outline-danger" id="commentDislikeBtn-${postId}-${comment.commentId}">👎</button>
            <span id="commentDislikeCount-${postId}-${comment.commentId}">${comment.dislikes ? comment.dislikes.length : 0}</span>            
            ${auth.currentUser && auth.currentUser.uid === comment.uid ? `<button id="delBtn-${postId}-${comment.commentId}" class="btn btn-sm btn-danger ms-2">삭제</button>` : ''}
            ${replyButtonHtml}
          </div>
          ${replyFormHtml}
        `;

        // --- 추가된 부분: 현재 사용자가 이미 좋아요/싫어요 한 경우 버튼 활성화 처리 --- 
        if (auth.currentUser) {
          const userId = auth.currentUser.uid;
          const commentLikeBtn = div.querySelector(`#commentLikeBtn-${postId}-${comment.commentId}`);
          const commentDislikeBtn = div.querySelector(`#commentDislikeBtn-${postId}-${comment.commentId}`);
          if (comment.likes && comment.likes.includes(userId)) {
            commentLikeBtn.classList.remove('btn-outline-primary');
            commentLikeBtn.classList.add('btn-primary');
          }
          if (comment.dislikes && comment.dislikes.includes(userId)) {
            commentDislikeBtn.classList.remove('btn-outline-danger');
            commentDislikeBtn.classList.add('btn-danger');
          }
        }
        // ---------------------------------------------------------------------------

        // 삭제 버튼 이벤트
        const delBtn = div.querySelector(`#delBtn-${postId}-${comment.commentId}`);
        if (delBtn) {
          delBtn.addEventListener('click', () => {
            openDeleteCommentModal(postId, comment.commentId);
          });
        }

        // 좋아요 / 싫어요 버튼 이벤트
        const commentLikeBtn = div.querySelector(`#commentLikeBtn-${postId}-${comment.commentId}`);
        const commentDislikeBtn = div.querySelector(`#commentDislikeBtn-${postId}-${comment.commentId}`);
        commentLikeBtn.addEventListener('click', () => {
          toggleCommentLike(postId, comment.commentId)
        });
        commentDislikeBtn.addEventListener('click', () => toggleCommentDislike(postId, comment.commentId));

        // 답글 버튼과 폼은 indent가 0인 경우(최상위 댓글)일 때만 이벤트를 등록합니다.
        if (indent === 0) {
          const replyBtn = div.querySelector(`#replyBtn-${postId}-${comment.commentId}`);
          const replyForm = div.querySelector(`#replyForm-${postId}-${comment.commentId}`);
          replyBtn.addEventListener('click', () => {
            replyForm.classList.toggle('d-none');
          });
          const replySubmitBtn = div.querySelector(`#replySubmitBtn-${postId}-${comment.commentId}`);
          replySubmitBtn.addEventListener('click', () => {
            const replyInput = div.querySelector(`#replyInput-${postId}-${comment.commentId}`);
            const text = replyInput.value.trim();
            if (text) {
              addComment(postId, text, comment.commentId);
              replyInput.value = '';
              replyForm.classList.add('d-none');
            }
          });
        }

        // 계급 아이콘 설정
        const rankIconEl = div.querySelector(`#commentRankIcon-${postId}-${comment.commentId}`);
        if (comment.uid) {
          fetchUserDoc(comment.uid).then(snap => {
            if (snap.exists()) {
              const userData = snap.data();
              const userScore = userData.score || 0;
              const rankInfo = getRankByScore(userScore);
              rankIconEl.textContent = rankInfo.icon;
              rankIconEl.addEventListener('click', () => {
                showToast(`계급: ${rankInfo.name} (${userScore}점)`, userData.nickname || '익명');
              });
            }
          });
        }

        // 자식 댓글 렌더링
        // indent가 0인 경우에만 2rem 들여쓰기로 증가하고, 그 이후엔 최대 들여쓰기를 유지합니다.
        if (comment.children && comment.children.length > 0) {
          // 최상위 댓글일 때는 indent 0 → 2, 답글인 경우는 계속 2rem을 유지
          const newIndent = indent === 0 ? indent + 2 : indent;
          comment.children.forEach(child => {
            const childDiv = renderCommentNode(child, newIndent);
            div.appendChild(childDiv);
          });
        }
        return div;
      }

      roots.forEach(comment => {
        const commentNode = renderCommentNode(comment, 0);
        containerEl.appendChild(commentNode);
      });
    }

    /********************************
     * 좋아요/싫어요 (게시글)
     ********************************/
    let likeDislikeInProgress = new Set();
    async function toggleLike(postId) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      if (likeDislikeInProgress.has(postId)) return;
      likeDislikeInProgress.add(postId);
      try {
        await runTransaction(db, async (transaction) => {
          const postRef = doc(db, 'posts', postId);
          const postSnap = await transaction.get(postRef);
          if (!postSnap.exists()) return;
          const data = postSnap.data();
          const likes = data.likes || [];
          const dislikes = data.dislikes || [];
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          let scoreDiff = 0;
          const alreadyLiked = likes.includes(user.uid);
          const alreadyDisliked = dislikes.includes(user.uid);
          if (alreadyLiked) {
            transaction.update(postRef, { likes: arrayRemove(user.uid) });
            scoreDiff -= 10;
          } else {
            transaction.update(postRef, { likes: arrayUnion(user.uid) });
            if (alreadyDisliked) {
              transaction.update(postRef, { dislikes: arrayRemove(user.uid) });
              scoreDiff += 5;
            }
            scoreDiff += 10;
          }
          transaction.update(userRef, { score: oldScore + scoreDiff });
        });
        const userData = await fetchUserNicknameAndScore(user.uid);
        currentScore = userData.score;
      } catch (err) {
        showToast(err.message, '오류');
      } finally {
        likeDislikeInProgress.delete(postId);
      }
    }
    async function toggleDislike(postId) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      if (likeDislikeInProgress.has(postId)) return;
      likeDislikeInProgress.add(postId);
      try {
        await runTransaction(db, async (transaction) => {
          const postRef = doc(db, 'posts', postId);
          const postSnap = await transaction.get(postRef);
          if (!postSnap.exists()) return;
          const data = postSnap.data();
          const likes = data.likes || [];
          const dislikes = data.dislikes || [];
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          let scoreDiff = 0;
          const alreadyLiked = likes.includes(user.uid);
          const alreadyDisliked = dislikes.includes(user.uid);
          if (alreadyDisliked) {
            transaction.update(postRef, { dislikes: arrayRemove(user.uid) });
            scoreDiff += 5;
          } else {
            transaction.update(postRef, { dislikes: arrayUnion(user.uid) });
            if (alreadyLiked) {
              transaction.update(postRef, { likes: arrayRemove(user.uid) });
              scoreDiff -= 10;
            }
            scoreDiff -= 5;
          }
          transaction.update(userRef, { score: oldScore + scoreDiff });
        });
        const userData = await fetchUserNicknameAndScore(user.uid);
        currentScore = userData.score;
      } catch (err) {
        showToast(err.message, '오류');
      } finally {
        likeDislikeInProgress.delete(postId);
      }
    }

    /********************************
     * 좋아요/싫어요 (댓글)
     ********************************/
    let commentLikeDislikeInProgress = new Set();
    async function toggleCommentLike(postId, commentId) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const key = `comment-${postId}-${commentId}`;
      if (commentLikeDislikeInProgress.has(key)) return;
      commentLikeDislikeInProgress.add(key);
      try {
        await runTransaction(db, async (transaction) => {
          const commentRef = doc(db, 'posts', postId, 'comments', commentId);
          const commentSnap = await transaction.get(commentRef);
          if (!commentSnap.exists()) return;
          const data = commentSnap.data();
          const likes = data.likes || [];
          const dislikes = data.dislikes || [];
          let scoreDiff = 0;
          const alreadyLiked = likes.includes(user.uid);
          const alreadyDisliked = dislikes.includes(user.uid);
          if (alreadyLiked) {
            transaction.update(commentRef, { likes: arrayRemove(user.uid) });
            scoreDiff -= 5;
          } else {
            transaction.update(commentRef, { likes: arrayUnion(user.uid) });
            if (alreadyDisliked) {
              transaction.update(commentRef, { dislikes: arrayRemove(user.uid) });
              scoreDiff += 3;
            }
            scoreDiff += 5;
          }
        });
      } catch (err) {
        showToast(err.message, '오류');
      } finally {
        commentLikeDislikeInProgress.delete(`comment-${postId}-${commentId}`);
      }
    }
    async function toggleCommentDislike(postId, commentId) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const key = `comment-${postId}-${commentId}`;
      if (commentLikeDislikeInProgress.has(key)) return;
      commentLikeDislikeInProgress.add(key);
      try {
        await runTransaction(db, async (transaction) => {
          const commentRef = doc(db, 'posts', postId, 'comments', commentId);
          const commentSnap = await transaction.get(commentRef);
          if (!commentSnap.exists()) return;
          const data = commentSnap.data();
          const likes = data.likes || [];
          const dislikes = data.dislikes || [];
          let scoreDiff = 0;
          const alreadyLiked = likes.includes(user.uid);
          const alreadyDisliked = dislikes.includes(user.uid);
          if (alreadyDisliked) {
            transaction.update(commentRef, { dislikes: arrayRemove(user.uid) });
            scoreDiff += 3;
          } else {
            transaction.update(commentRef, { dislikes: arrayUnion(user.uid) });
            if (alreadyLiked) {
              transaction.update(commentRef, { likes: arrayRemove(user.uid) });
              scoreDiff -= 5;
            }
            scoreDiff -= 3;
          }
        });
      } catch (err) {
        showToast(err.message, '오류');
      } finally {
        commentLikeDislikeInProgress.delete(`comment-${postId}-${commentId}`);
      }
    }

    /********************************
     * 개별 글 DOM 생성 (게시글 내용, 좋아요/싫어요, 수정/삭제, 마법, 댓글 등)
     ********************************/
    async function createPostItem(docSnap) {
      const data = docSnap.data();
      const postId = docSnap.id;
      const card = document.createElement('div');
      card.className = 'card mb-3';
      card.id = 'postCard-' + postId;
      let authorNickname = data.nickname || '익명';
      let authorRankEmoji = '';
      let authorScore = 0;
      try {
        const snap = await fetchUserDoc(data.uid);
        if (snap.exists()) {
          const userData = snap.data();
          authorScore = userData.score || 0;
          const rankInfo = getRankByScore(userData.score || 0);
          authorRankEmoji = rankInfo.icon;
          authorNickname = userData.nickname || authorNickname;
        }
      } catch (_) {}
      let isAuthor = false;
      const currentUser = auth.currentUser;
      if (currentUser && currentUser.uid === data.uid) isAuthor = true;
      const likeCount = data.likes ? data.likes.length : 0;
      const dislikeCount = data.dislikes ? data.dislikes.length : 0;
      const title = DOMPurify.sanitize(data.title, { ALLOWED_TAGS: [] });
      const finalContent = convertYouTubeLinks(data.content);
      card.innerHTML = `
        <div class="card-header fw-bold d-flex justify-content-between align-items-center">
          <span>${title}</span>
          <div class="action-buttons">
            ${isAuthor ? `
              <button class="btn btn-sm btn-warning me-2" id="editBtn-${postId}">수정</button>
              <button class="btn btn-sm btn-danger me-2" id="deleteBtn-${postId}">삭제</button>
            ` : ''}
            ${currentUser ? `<button class="btn btn-sm magic-btn" id="magicBtn-${postId}">💫</button>` : ''}
          </div>
        </div>
        <div class="card-body">
          <h6 class="card-subtitle text-muted mb-2 post-subtitle">
            <span>작성자: ${authorNickname} <span style="cursor:pointer;" id="rankIcon-${postId}">${authorRankEmoji}</span></span>
            <span>${formatDateTime(data.createdAt)}</span>
          </h6>
          <div class="card-text mt-2 toastui-editor-contents">${finalContent}</div>
          <div class="mt-3 d-flex align-items-center gap-2">
            <button class="btn btn-sm btn-outline-primary" id="likeBtn-${postId}">👍</button>
            <span id="likeCount-${postId}">${likeCount}</span>
            <button class="btn btn-sm btn-outline-danger" id="dislikeBtn-${postId}">👎</button>
            <span id="dislikeCount-${postId}">${dislikeCount}</span>
            <span class="vr mx-2"></span>
            <button class="btn btn-sm btn-outline-secondary" id="shareBtn-${postId}">🔗</button>
          </div>
          <div class="mt-3">
            <h6 id="commentHeader-${postId}">댓글</h6>
            <div id="commentList-${postId}"></div>
          </div>
          <div class="mt-2 d-none" id="commentForm-${postId}">
            <textarea class="form-control mb-2" rows="2" placeholder="댓글을 입력하세요" id="commentInput-${postId}"></textarea>
            <button class="btn btn-secondary" id="commentBtn-${postId}">댓글 달기</button>
          </div>
        </div>
      `;
      if (currentUser) {
        const magicBtn = card.querySelector(`#magicBtn-${postId}`);
        if (magicBtn) {
          magicBtn.addEventListener('click', () => {
            if (currentUser.uid !== data.uid && currentScore <= authorScore) {
              showToast("마력이 미치지 않습니다.", "마법");
              return;
            }
            openMagicModal(postId, data, authorScore);
          });
        }
      }
      if (isAuthor) {
        const editBtn = card.querySelector(`#editBtn-${postId}`);
        editBtn.addEventListener('click', async () => {
          const postSnap = await getDoc(doc(db, 'posts', postId));
          if (postSnap.exists()) openEditModal(postSnap);
          else showToast('글 정보를 불러오지 못했습니다.', '오류');
        });
        const deleteBtn = card.querySelector(`#deleteBtn-${postId}`);
        deleteBtn.addEventListener('click', async () => {
          const postSnap = await getDoc(doc(db, 'posts', postId));
          if (postSnap.exists()) await deletePost(postSnap);
        });
      }
      const likeBtn = card.querySelector(`#likeBtn-${postId}`);
      const dislikeBtn = card.querySelector(`#dislikeBtn-${postId}`);
      likeBtn.addEventListener('click', () => {
        likeBtn.classList.add('like-flame');
        toggleLike(postId);
        setTimeout(() => {
          likeBtn.classList.remove('like-flame');
        }, 500);
      });
      dislikeBtn.addEventListener('click', () => toggleDislike(postId));
      const shareBtn = card.querySelector(`#shareBtn-${postId}`);
      shareBtn.addEventListener('click', () => {
        const shareUrl = window.location.origin + window.location.pathname + '?postId=' + postId;
        navigator.clipboard.writeText(shareUrl).then(() => {
          showToast('URL 복사되었습니다.', '공유');
        }).catch((err) => {
          showToast('URL 복사 실패: ' + err, '공유');
        });
      });
      if (currentUser) {
        if (data.likes?.includes(currentUser.uid)) {
          likeBtn.classList.remove('btn-outline-primary');
          likeBtn.classList.add('btn-primary');
        }
        if (data.dislikes?.includes(currentUser.uid)) {
          dislikeBtn.classList.remove('btn-outline-danger');
          dislikeBtn.classList.add('btn-danger');
        }
      }
      const commentListEl = card.querySelector(`#commentList-${postId}`);
      const commentFormEl = card.querySelector(`#commentForm-${postId}`);
      const commentInputEl = card.querySelector(`#commentInput-${postId}`);
      const commentBtn = card.querySelector(`#commentBtn-${postId}`);
      if (currentUser) commentFormEl.classList.remove('d-none');
      commentBtn.addEventListener('click', () => {
        const text = commentInputEl.value.trim();
        addComment(postId, text);
        commentInputEl.value = '';
      });
      const rankIconEl = card.querySelector(`#rankIcon-${postId}`);
      rankIconEl.addEventListener('click', async () => {
        try {
          const snap = await fetchUserDoc(data.uid);
          if (snap.exists()) {
            const uData = snap.data();
            const s = uData.score || 0;
            const rInfo = getRankByScore(s);
            showToast(`계급: ${rInfo.name} (${s}점)`, authorNickname);
          } else {
            showToast('유저 정보 없음', '알림');
          }
        } catch (err) {
          showToast(err.message, '알림');
        }
      });
      if (data.magic && data.magic.expiresAt) {
        const now = new Date();
        const exp = new Date(data.magic.expiresAt.seconds * 1000);
        if (now < exp) card.classList.add(data.magic.magicType);
      }
      return card;
    }

    /********************************
     * 마법 관련 함수
     ********************************/
    async function openMagicModal(postId, postData, authorScore) {
      const magicModalEl = document.getElementById('magicModal');
      const magicModal = new bootstrap.Modal(magicModalEl);
      const magicPostIdInput = document.getElementById('magicPostId');
      const magicInfoDiv = document.getElementById('magicInfo');
      const magicModalFooter = document.getElementById('magicModalFooter');
      magicPostIdInput.value = postId;
      const postRef = doc(db, 'posts', postId);
      const postSnap = await getDoc(postRef);
      const postDocData = postSnap.data();
      let magic = postDocData.magic || null;
      if (magic && magic.expiresAt) {
        const now = new Date();
        const exp = new Date(magic.expiresAt.seconds * 1000);
        if (now >= exp) magic = null;
      }
      magicInfoDiv.innerHTML = "";
      magicModalFooter.innerHTML = "";
      if (magic) {
        magicInfoDiv.innerHTML = `
          <p>현재 적용된 마법: <strong>${magicDisplayNames[magic.magicType]}</strong></p>
          <p>시전자: <strong>${magic.casterNickname || '알 수 없음'}</strong></p>
          <p>종료 시각: <strong>${magic.expiresAt ? formatDateTime(magic.expiresAt) : '알 수 없음'}</strong></p>
        `;
        const casterSnap = await getDoc(doc(db, 'users', magic.casterUid));
        const casterData = casterSnap.exists() ? casterSnap.data() : null;
        const casterScore = casterData ? (casterData.score || 0) : 0;
        if (currentScore >= casterScore) {
          const removeBtn = document.createElement('button');
          removeBtn.className = 'btn btn-danger';
          removeBtn.textContent = '마법 해제';
          removeBtn.addEventListener('click', () => removeMagic(postId));
          magicModalFooter.appendChild(removeBtn);
        }
        const closeBtn = document.createElement('button');
        closeBtn.className = 'btn btn-secondary';
        closeBtn.textContent = '닫기';
        closeBtn.setAttribute('data-bs-dismiss', 'modal');
        magicModalFooter.appendChild(closeBtn);
      } else {
        if (auth.currentUser.uid === postData.uid || currentScore > authorScore) {
          const rankInfo = getRankByScore(currentScore);
          const availableMagic = getAvailableMagicTypes(rankInfo.name);
          let radioHTML = `<p>이 글에 시전할 마법을 선택하세요:</p>`;
          availableMagic.forEach((magicType, index) => {
            const displayName = magicDisplayNames[magicType] || magicType;
            radioHTML += `
              <div class="form-check">
                <input class="form-check-input" type="radio" name="magicRadio" id="magicRadio-${magicType}" value="${magicType}" ${index===0 ? 'checked' : ''}>
                <label class="form-check-label" for="magicRadio-${magicType}">${displayName}</label>
              </div>`;
          });
          magicInfoDiv.innerHTML = radioHTML;
          const castBtn = document.createElement('button');
          castBtn.className = 'btn btn-primary';
          castBtn.textContent = '마법 시전';
          castBtn.addEventListener('click', () => {
            const radios = document.getElementsByName('magicRadio');
            let selectedMagic;
            for (let radio of radios) {
              if (radio.checked) { selectedMagic = radio.value; break; }
            }
            castMagic(postId, postData, selectedMagic);
          });
          magicModalFooter.appendChild(castBtn);
        } else {
          magicInfoDiv.innerHTML = `<p>포인트가 부족하여 마법을 시전할 수 없습니다.</p>`;
        }
        const closeBtn = document.createElement('button');
        closeBtn.className = 'btn btn-secondary';
        closeBtn.textContent = '닫기';
        closeBtn.setAttribute('data-bs-dismiss', 'modal');
        magicModalFooter.appendChild(closeBtn);
      }
      magicModal.show();
    }
    async function castMagic(postId, postData, magicType) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const durationMapping = {
        'magic-basic': 3000,
        'magic-shimmer': 3000,
        'magic-blessing': 4000,
        'magic-curse': 4000,
        'magic-font': 5000,
        'magic-title': 5000,
        'magic-rainbow': 6000,
        'magic-ultimate': 6000
      };
      const duration = durationMapping[magicType] || 300;
      const expiresAt = Timestamp.fromDate(new Date(Date.now() + duration * 1000));
      try {
        await runTransaction(db, async (transaction) => {
          const postRef = doc(db, 'posts', postId);
          const postSnap = await transaction.get(postRef);
          if (!postSnap.exists()) throw new Error('글을 찾을 수 없습니다.');
          transaction.update(postRef, {
            magic: {
              magicType: magicType,
              casterUid: user.uid,
              casterNickname: currentNickname,
              castTime: serverTimestamp(),
              duration: duration,
              expiresAt: expiresAt
            }
          });
        });
        showToast('마법이 시전되었습니다!', '마법');
        const cardEl = document.getElementById(`postCard-${postId}`);
        if (cardEl) cardEl.classList.add(magicType);
        bootstrap.Modal.getInstance(document.getElementById('magicModal')).hide();
      } catch (err) {
        showToast(err.message, '마법 시전 실패');
      }
    }
    async function removeMagic(postId) {
      try {
        await runTransaction(db, async (transaction) => {
          const postRef = doc(db, 'posts', postId);
          const postSnap = await transaction.get(postRef);
          if (!postSnap.exists()) throw new Error('글을 찾을 수 없습니다.');
          transaction.update(postRef, { magic: deleteField() });
        });
        showToast('마법이 해제되었습니다.', '마법');
        const cardEl = document.getElementById(`postCard-${postId}`);
        if (cardEl) cardEl.className = cardEl.className.replace(/\bmagic-\S+\b/g, '');
        bootstrap.Modal.getInstance(document.getElementById('magicModal')).hide();
      } catch (err) {
        showToast(err.message, '마법 해제 실패');
      }
    }

    /********************************
     * 실시간 글 UI 및 댓글 업데이트, 무한 스크롤
     ********************************/
     function updatePostUI(postSnap) {
      const postId = postSnap.id;
      const data = postSnap.data();
      const likeCountEl = document.getElementById(`likeCount-${postId}`);
      const dislikeCountEl = document.getElementById(`dislikeCount-${postId}`);
      if (likeCountEl) likeCountEl.textContent = data.likes?.length || 0;
      if (dislikeCountEl) dislikeCountEl.textContent = data.dislikes?.length || 0;
      
      // → 추가: 좋아요/싫어요 버튼 상태 업데이트
      const currentUser = auth.currentUser;
      const likeBtn = document.getElementById(`likeBtn-${postId}`);
      const dislikeBtn = document.getElementById(`dislikeBtn-${postId}`);
      if (likeBtn) {
        if (currentUser && data.likes && data.likes.includes(currentUser.uid)) {
          likeBtn.classList.remove('btn-outline-primary');
          likeBtn.classList.add('btn-primary');
        } else {
          likeBtn.classList.remove('btn-primary');
          likeBtn.classList.add('btn-outline-primary');
        }
      }
      if (dislikeBtn) {
        if (currentUser && data.dislikes && data.dislikes.includes(currentUser.uid)) {
          dislikeBtn.classList.remove('btn-outline-danger');
          dislikeBtn.classList.add('btn-danger');
        } else {
          dislikeBtn.classList.remove('btn-danger');
          dislikeBtn.classList.add('btn-outline-danger');
        }
      }
      
      // 기존의 마법 효과 및 burning 효과 처리
      const cardEl = document.getElementById(`postCard-${postId}`);
      if (cardEl) {
        if (data.magic && data.magic.expiresAt) {
          const now = new Date();
          const exp = new Date(data.magic.expiresAt.seconds * 1000);
          if (now < exp) {
            cardEl.className = cardEl.className.replace(/\bmagic-\S+\b/g, '');
            cardEl.classList.add(data.magic.magicType);
          } else {
            cardEl.className = cardEl.className.replace(/\bmagic-\S+\b/g, '');
          }
        } else {
          cardEl.className = cardEl.className.replace(/\bmagic-\S+\b/g, '');
        }
        if (data.likes && data.likes.length >= 2) {
          cardEl.classList.add('burning');
        } else {
          cardEl.classList.remove('burning');
        }
      }
    }

    let lastVisible = null;
    let isLoading = false;
    const PAGE_SIZE = 5;
    async function loadMorePosts() {
      if (isLoading) return;
      isLoading = true;
      let q = query(
        collection(db, 'posts'),
        orderBy('createdAt', 'desc'),
        limit(PAGE_SIZE)
      );
      if (lastVisible) {
        q = query(
          collection(db, 'posts'),
          orderBy('createdAt', 'desc'),
          startAfter(lastVisible),
          limit(PAGE_SIZE)
        );
      }
      const snapshot = await getDocs(q);
      if (!snapshot.empty) {
        let newLastDoc = null;
        for (let docSnap of snapshot.docs) {
          const item = await createPostItem(docSnap);

          // 퀴즈 카드 하나 삽입
          if(Math.random() < 0.3) {
            const quizCard = createQuizCard();
            postList.appendChild(quizCard);
          }

          postList.appendChild(item);
          onSnapshot(doc(db, 'posts', docSnap.id), (updatedSnap) => {
            if (updatedSnap.exists()) updatePostUI(updatedSnap);
          });
          if (!commentUnsubscribers[docSnap.id]) {
            const cmtQuery = query(
              collection(db, 'posts', docSnap.id, 'comments'),
              orderBy('createdAt', 'asc')
            );
            commentUnsubscribers[docSnap.id] = onSnapshot(cmtQuery, (cmtSnapshot) => {
              const cmtData = [];
              cmtSnapshot.forEach((cmtDoc) => {
                const cdata = cmtDoc.data();
                cdata.commentId = cmtDoc.id;
                cmtData.push(cdata);
              });
              const commentListEl = document.querySelector(`#commentList-${docSnap.id}`);
              if (commentListEl) renderComments(docSnap.id, cmtData, commentListEl);
            });
          }
          newLastDoc = docSnap;
        }
        lastVisible = newLastDoc;
      }
      isLoading = false;
    }

    async function awardQuizPoint() {
      const user = auth.currentUser;
      if (!user) {
        showToast("로그인이 필요합니다.", "오류");
        return;
      }
      try {
        await runTransaction(db, async (transaction) => {
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          transaction.update(userRef, { score: oldScore + 1 });
        });
        showToast("퀴즈 포인트 1점 획득!", "퀴즈 챌린지");
      } catch (err) {
        showToast(err.message, "오류");
      }
    }

    window.addEventListener('scroll', () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 100) loadMorePosts();
    });

    /********************************
     * 랭킹 관련 (무한 스크롤)
     ********************************/
    let rankingLastVisible = null;
    let isRankingLoading = false;
    let rankingCount = 0;
    const RANKING_PAGE_SIZE = 10;
    async function loadMoreRanking() {
      if (isRankingLoading) return;
      isRankingLoading = true;
      let q = query(
        collection(db, 'users'),
        orderBy('score', 'desc'),
        limit(RANKING_PAGE_SIZE)
      );
      if (rankingLastVisible) {
        q = query(
          collection(db, 'users'),
          orderBy('score', 'desc'),
          startAfter(rankingLastVisible),
          limit(RANKING_PAGE_SIZE)
        );
      }
      const snapshot = await getDocs(q);
      const rankingContainer = document.getElementById('rankingContainer');
      if (!snapshot.empty) {
        snapshot.forEach(docSnap => {
          rankingCount++;
          const userData = docSnap.data();
          const rankInfo = getRankByScore(userData.score || 0);
          const item = document.createElement('div');
          item.className = 'p-2 border-bottom';
          item.innerHTML = `<strong>${rankingCount}위</strong> - ${userData.nickname || '익명'} : ${userData.score}점 ${rankInfo.icon}`;
          rankingContainer.appendChild(item);
          rankingLastVisible = docSnap;
        });
      }
      isRankingLoading = false;
    }
    const rankingModalEl = document.getElementById('rankingModal');
    rankingModalEl.addEventListener('show.bs.modal', () => {
      rankingLastVisible = null;
      rankingCount = 0;
      document.getElementById('rankingContainer').innerHTML = '';
      loadMoreRanking();
    });
    const rankingContainer = document.getElementById('rankingContainer');
    rankingContainer.addEventListener('scroll', () => {
      if (rankingContainer.scrollTop + rankingContainer.clientHeight >= rankingContainer.scrollHeight - 50) loadMoreRanking();
    });

    /********************************
     * 폭죽(Confetti) 애니메이션
     ********************************/
    function launchFireworks() {
      const duration = 2000;
      const animationEnd = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 1000 };
      const interval = setInterval(() => {
        const timeLeft = animationEnd - Date.now();
        if (timeLeft <= 0) { clearInterval(interval); return; }
        const particleCount = 50 * (timeLeft / duration);
        confetti(Object.assign({}, defaults, {
          particleCount,
          origin: { x: Math.random(), y: Math.random() - 0.2 }
        }));
      }, 250);
    }
    async function highlightPostFromQuery() {
      const urlParams = new URLSearchParams(window.location.search);
      const highlightPostId = urlParams.get('postId');
      if (!highlightPostId) return;
      const existingCard = document.getElementById('postCard-' + highlightPostId);
      if (existingCard) {
        if (postList.firstChild !== existingCard) {
          postList.insertBefore(existingCard, postList.firstChild);
        }
        existingCard.style.border = '3px solid gold';
      } else {
        const postRef = doc(db, 'posts', highlightPostId);
        const postSnap = await getDoc(postRef);
        if (postSnap.exists()) {
          const card = await createPostItem(postSnap);
          card.style.border = '3px solid gold';
          postList.insertBefore(card, postList.firstChild);
          
          // → 추가: 실시간 업데이트를 위한 onSnapshot 리스너 등록 (게시글)
          onSnapshot(postRef, (updatedSnap) => {
            if (updatedSnap.exists()) updatePostUI(updatedSnap);
          });
          
          // → 추가: 댓글 리스너 등록 (댓글이 보이지 않는 버그 수정)
          if (!commentUnsubscribers[highlightPostId]) {
            const cmtQuery = query(
              collection(db, 'posts', highlightPostId, 'comments'),
              orderBy('createdAt', 'asc')
            );
            commentUnsubscribers[highlightPostId] = onSnapshot(cmtQuery, (cmtSnapshot) => {
              const cmtData = [];
              cmtSnapshot.forEach((cmtDoc) => {
                const cdata = cmtDoc.data();
                cdata.commentId = cmtDoc.id;
                cmtData.push(cdata);
              });
              const commentListEl = document.querySelector(`#commentList-${highlightPostId}`);
              if (commentListEl) renderComments(highlightPostId, cmtData, commentListEl);
            });
          }
        }
      }
}

    deleteAccountBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인 상태가 아닙니다.', '오류');
        return;
      }
      if (!confirm('회원탈퇴 시, 작성하신 댓글은 삭제되지 않고 남습니다.\n댓글은 별도로 직접 삭제하셔야 하며,\n댓글을 제외한 모든 작성글과 계정이 완전히 삭제됩니다.\n정말로 탈퇴하시겠습니까?')) return;
      try {
        const postsQuery = query(collection(db, 'posts'), where('uid', '==', user.uid));
        const postsSnapshot = await getDocs(postsQuery);
        const deletePromises = postsSnapshot.docs.map(docSnap => deleteDoc(docSnap.ref));
        await Promise.all(deletePromises);
        await deleteDoc(doc(db, 'users', user.uid));
        await deleteUser(user);
        showToast('회원탈퇴가 완료되었습니다.', '회원탈퇴');
        await signOut(auth);
      } catch (err) {
        showToast(err.message, '회원탈퇴 실패');
      }
    });
    fetchActiveNotices();
    loadMorePosts().then(() => { highlightPostFromQuery(); });
  </script>
</body>
</html>
