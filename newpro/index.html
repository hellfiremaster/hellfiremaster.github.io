<!DOCTYPE html>
<html lang="ko">
<head>
  <meta name="description" content="코딩은 모험이다! 뉴프로 커뮤니티에서 아이디어를 나누고, 즐거운 코드 토크를 펼쳐보세요!" />
  <meta name="keywords" content="코딩, 커뮤니티, 프로그래밍, 개발자, 뉴프로" />
  <meta name="author" content="프로그래밍 갤러리 위원회" />
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#2a4065">
  <meta property="og:title" content="뉴프로 커뮤니티" />
  <meta property="og:description" content="코딩은 모험이다! 뉴프로 커뮤니티에서 아이디어를 나누고, 즐거운 코드 토크를 펼쳐보세요!" />
  <title>뉴프로 커뮤니티</title>

  <!-- Google Font (Jua) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link 
    href="https://fonts.googleapis.com/css2?family=Jua&display=swap"
    rel="stylesheet"
  />
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue:wght@400;700&display=swap" rel="stylesheet">

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" />

  <!-- Toast UI Editor: CSS/JS, 코드블록 하이라이트 플러그인 -->
  <link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
  <script src="https://uicdn.toast.com/editor/latest/toastui-editor-all.min.js"></script>
  <link rel="stylesheet" href="https://uicdn.toast.com/editor-plugin-code-syntax-highlight/latest/toastui-editor-plugin-code-syntax-highlight.min.css" />
  <script src="https://uicdn.toast.com/editor-plugin-code-syntax-highlight/latest/toastui-editor-plugin-code-syntax-highlight.min.js"></script>

  <!-- DOMPurify -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.2.3/purify.min.js" integrity="sha512-Ll+TuDvrWDNNRnFFIM8dOiw7Go7dsHyxRp4RutiIFW/wm3DgDmCnRZow6AqbXnCbpWu93yM1O34q+4ggzGeXVA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <style>
    /* 기본 배경 및 글꼴 등 */
    body {
      background: linear-gradient(135deg, #1f2945, #2a4065);
      min-height: 100vh;
      color: #fff;
      margin: 0;
      padding: 0;
    }
    .navbar {
      background: rgba(10, 10, 20, 0.7) !important;
    }
    .navbar-brand {
      font-family: 'Jua', sans-serif;
      font-size: 1.8rem;
    }
    .hero-section {
      text-align: center;
      padding: 3rem 1rem;
      background: transparent;
    }
    .hero-title {
      font-size: 3rem;
      font-weight: bold;
      margin-bottom: 1rem;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
      color: #fff;
      font-family: 'Jua', sans-serif;
    }
    .hero-subtitle {
      font-size: 1.25rem;
      opacity: 0.9;
      text-shadow: 1px 1px 3px rgba(0,0,0,0.4);
      color: #d5d9e0;
      font-family: 'Jua', sans-serif;
    }
    .glass-card {
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(8px);
      border-radius: 1rem;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      color: #000;
    }
    .toast-container {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
    }
    .toast.dark-bg {
      background-color: rgba(0,0,0,0.8);
      color: #fff;
    }
    .toast.dark-bg .toast-header {
      background-color: transparent;
      color: #fff;
      border-bottom: 1px solid #666;
    }
    .toast.dark-bg .btn-close {
      filter: invert(1);
    }
    .d-none {
      display: none !important;
    }
    .modal-content {
      background-color: #fff !important;
      color: #000 !important;
    }
    .comment-item {
      background-color: #f8f9fa;
      border-radius: 0.5rem;
      padding: 0.5rem 1rem;
      margin-bottom: 0.5rem;
      color: #000;
    }
    .post-subtitle {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
    .auth-loading {
      animation: spin 1.0s linear infinite;
    }
    #postList img {
      max-width: 100%;
      height: auto;
    }
    .shining-btn {
      position: relative;
      overflow: hidden;
      background-color: #ff69b4;
      color: #fff;
      border: none;
      border-radius: 5px;
      box-shadow: 0 0 8px rgba(255,105,180, 0.6);
      font-weight: bold;
      cursor: pointer;
    }
    .shining-btn::before {
      content: "";
      position: absolute;
      top: -100%;
      left: -100%;
      width: 200%;
      height: 200%;
      background: linear-gradient(
        45deg,
        rgba(255, 255, 255, 0.7) 0%,
        rgba(255, 255, 255, 0) 40%,
        rgba(255, 255, 255, 0) 60%,
        rgba(255, 255, 255, 0.7) 100%
      );
      animation: shine 2.5s infinite;
      transform: rotate(0deg);
    }
    @keyframes shine {
      0% {
        transform: translate(-100%, -100%);
      }
      50% {
        transform: translate(100%, 100%);
      }
      100% {
        transform: translate(-100%, -100%);
      }
    }
    .keep-line-breaks {
      white-space: pre-line;
    }
    .notice-banner {
      background: linear-gradient(130deg, #002f2f, #004a3f);
      border: 1px solid #0a7f5f;
      border-radius: 0.5rem;
      padding: 1rem;
      margin-bottom: 1rem;
      position: relative;
      overflow: hidden;
      box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
      color: #69ffa2;
      font-weight: bold;
      text-shadow: 0 0 5px #69ffa2, 0 0 10px #69ffa2;
      transition: filter 0.3s;
      cursor: pointer;
    }
    .notice-banner:hover {
      filter: brightness(1.2);
    }
    .notice-banner p {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-all;
    }
    .video-responsive {
      position: relative;
      width: 560px;
      max-width: 100%;
      margin: 1rem 0;
    }
    .video-responsive::before {
      content: "";
      display: block;
      padding-top: 56.25%;
    }
    .video-responsive iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100% !important;
      height: 100% !important;
      border: 0;
    }
    .magic-btn {
      position: relative;
      overflow: hidden;
      color: #000;
      border-radius: 5px;
      margin-left: 5px;
      padding: 2px 6px;
      transition: box-shadow 0.3s;
    }
    .magic-btn:hover {
      box-shadow: 0 0 8px 2px rgba(255, 215, 0, 0.8);
    }
    .magic-btn:disabled {
      border: none !important;
      box-shadow: none !important;
    }
    .magic-shimmer {
      background: linear-gradient(90deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.5) 50%, rgba(255,255,255,0.1) 100%);
      background-size: 200% auto;
      animation: shimmer 1.5s linear infinite;
    }
    @keyframes shimmer {
      0% { background-position: 200% center; }
      100% { background-position: -200% center; }
    }
    .magic-blessing {
      background: linear-gradient(45deg, rgba(255,215,0,0.4), rgba(255,215,0,0.8));
      animation: blessingPulse 2s ease-in-out infinite;
    }
    @keyframes blessingPulse {
      0%, 100% { box-shadow: 0 0 10px 2px rgba(255,215,0,0.8); }
      50% { box-shadow: 0 0 20px 4px rgba(255,215,0,1); }
    }
    .magic-curse {
      filter: invert(1) blur(2px);
    }
    .magic-font {
      font-family: 'Comic Neue', cursive, sans-serif !important;
      color: #d9534f;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .magic-title {
      direction: rtl;
      unicode-bidi: bidi-override;
    }
    .magic-rainbow {
      background: linear-gradient(45deg,
        rgba(255, 0, 0, 0.4),
        rgba(255, 165, 0, 0.4),
        rgba(255, 255, 0, 0.4),
        rgba(0, 128, 0, 0.4),
        rgba(0, 0, 255, 0.4),
        rgba(75, 0, 130, 0.4),
        rgba(238, 130, 238, 0.4)
      );
      animation: rainbowPulse 2s ease-in-out infinite;
    }
    @keyframes rainbowPulse {
      0%, 100% {
        box-shadow: 0 0 10px 2px rgba(255, 0, 0, 0.8);
      }
      50% {
        box-shadow: 0 0 20px 4px rgba(238, 130, 238, 1);
      }
    }
    .magic-ultimate {
      background: radial-gradient(circle, rgba(255,215,0,0.4), rgba(255,215,0,0.2), rgba(0,0,0,0));
      animation: ultimateGlow 30s infinite, pulseGlow 2s infinite, borderGlow 2s infinite;
      border: 3px solid #ff595e;
      box-shadow: 0 0 10px 5px #ff595e;
    }

    @keyframes ultimateGlow {
      0%   { transform: scale(0.9) rotate(-10deg); }
      25%   { transform: scale(0.9) rotate(360deg); }
      50%  { transform: scale(1.1) rotate(10deg); }
      50%  { transform: scale(1.25) rotate(10deg); }
      100% { transform: scale(0.9) rotate(-10deg); }
    }

    @keyframes pulseGlow {
      0%, 100% { box-shadow: 0 0 10px 5px rgba(255,215,0,0.7); }
      50% { box-shadow: 0 0 20px 10px rgba(255,215,0,1); }
    }

    @keyframes borderGlow {
      0% { border-color: #ff595e; box-shadow: 0 0 10px 5px #ff595e; }
      25% { border-color: #ffca3a; box-shadow: 0 0 10px 5px #ffca3a; }
      50% { border-color: #8ac926; box-shadow: 0 0 10px 5px #8ac926; }
      75% { border-color: #1982c4; box-shadow: 0 0 10px 5px #1982c4; }
      100% { border-color: #ff595e; box-shadow: 0 0 10px 5px #ff595e; }
    }

    .magic-basic {
      animation: basicGlow 2s infinite;
    }
    @keyframes basicGlow {
      0% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.5); }
      50% { box-shadow: 0 0 15px rgba(0, 255, 255, 1); }
      100% { box-shadow: 0 0 5px rgba(0, 255, 255, 0.5); }
    }
    @media (max-width: 576px) {
      .action-buttons {
        margin-left: auto;
        text-align: right;
        display: flex;
        gap: 0.1rem;
      }
    }

    /* 좋아요(추천) 버튼 타오르는 애니메이션 */
    @keyframes likeFlame {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4); /* 파란색 (Bootstrap primary 색상 계열) */
      }
      50% {
        transform: scale(1.05);
        box-shadow: 0 0 10px 6px rgba(0, 123, 255, 0.4);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(0, 123, 255, 0.4);
      }
    }
    .like-flame {
      animation: likeFlame 0.5s ease-in-out;
    }
    .adventure {
      font-family: 'Jua', sans-serif !important;
    }

    @keyframes burningAnimation {
      0% {
        filter: brightness(1) drop-shadow(0 0 5px rgba(255, 69, 0, 0.8));
      }
      50% {
        filter: brightness(1) drop-shadow(0 0 15px rgba(255, 69, 0, 1));
      }
      100% {
        filter: brightness(1) drop-shadow(0 0 5px rgba(255, 69, 0, 0.8));
      }
    }
    .burning {
      animation: burningAnimation 1.5s infinite;
    }

    /* 단일 이모지일 경우 크게 보이도록 하는 CSS */
    .emoji-large {
      font-size: 4rem; /* 원하는 크기로 조정 */
      line-height: 1;
    }

    /* Toast UI Editor 컨텐츠의 기본 글씨 크기를 18px로 설정 */
    .toastui-editor-contents {
      font-size: 16px;
    }

  /* 퀴즈 카드 전용 스타일 */
  .quiz-card {
    border: 2px solid #4CAF50;
    background: rgba(255, 255, 255, 0.9);
    color: #333;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    margin-top: 1rem;
  }
  .quiz-card .card-title {
    color: #4CAF50;
  }
  .quiz-option {
    margin: 0.3rem;
  }
  </style>
</head>
<body>
  <!-- 네비게이션 바 -->
  <nav class="navbar navbar-expand-lg navbar-dark">
    <div class="container">
      <span class="navbar-brand fw-bold">뉴프로</span>
      <div class="ms-auto">
        <button class="btn btn-outline-light me-2 auth-loading" id="authLoadingBtn">로딩중...</button>
        <button class="btn btn-outline-light me-2 d-none" id="loginBtn" data-bs-toggle="modal" data-bs-target="#loginModal">로그인</button>
        <button class="btn btn-success me-2 d-none" id="signupBtn" data-bs-toggle="modal" data-bs-target="#signupModal">회원가입</button>
        <!-- 로그인 시 보여질 사용자 프로필(드롭다운) -->
        <div class="dropdown d-none" id="userDropdown">
          <button class="btn btn-outline-light dropdown-toggle" type="button" id="userDropdownMenuButton" data-bs-toggle="dropdown" aria-expanded="false">
            <!-- 닉네임, 등급, 점수로 동적 업데이트 -->
          </button>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="userDropdownMenuButton">
            <!-- <li><a class="dropdown-item" href="#">프로필</a></li> -->
            <!-- <li><hr class="dropdown-divider"></li> -->
            <a class="dropdown-item" href="terms.html" target="_blank">📜 이용 약관</a>
            <li><a class="dropdown-item" href="#" id="logoutBtnDropdown">🚪 로그아웃</a></li>
          </ul>
        </div>
      </div>
    </div>
  </nav>

  <!-- Hero Section -->
  <section class="hero-section">
    <h1 class="hero-title">코딩은 모험이다!</h1>
    <p class="hero-subtitle">뉴프로 커뮤니티에서 아이디어를 마음껏 나누고, 즐거운 코드 토크를 펼쳐보세요!</p>
  </section>

  <!-- 메인 컨테이너 -->
  <div class="container mb-5">
    <div class="d-flex justify-content-end mb-2">
      <button class="btn shining-btn me-2" id="showRankBtn" data-bs-toggle="modal" data-bs-target="#rankModal">내 계급 보기</button>
      <button class="btn btn-outline-info me-2" id="showRankingBtn" data-bs-toggle="modal" data-bs-target="#rankingModal">랭킹</button>
      <button class="btn btn-light d-none" id="togglePostFormBtn">글쓰기</button>
    </div>

    <div id="noticeContainer" class="notice-container mb-3"></div>

    <!-- 글쓰기 카드 (숨김) -->
    <div class="card glass-card p-3 d-none" id="postCard">
      <div class="card-body">
        <h5 class="card-title">새 글 작성</h5>
        <div class="mb-3">
          <label for="postTitle" class="form-label">제목</label>
          <input type="text" class="form-control" id="postTitle" placeholder="제목을 입력하세요" />
        </div>
        <div class="mb-3">
          <label for="editor" class="form-label">내용</label>
          <div id="editor"></div>
        </div>
        <button class="btn btn-primary mt-2" id="savePostBtn">글 저장하기</button>
      </div>
    </div>

    <!-- 글 목록 카드 -->
    <div class="card glass-card mt-4">
      <div class="card-body px-0 px-md-3">
        <h4 class="card-title adventure text-center">모험의 기록</h4>
        <div id="postList" class="mt-3"><!-- 게시글 목록이 로드됩니다 --></div>
      </div>
    </div>
  </div>

  <!-- [수정 모달] -->
  <div class="modal fade" id="editModal" tabindex="-1" aria-labelledby="editModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-xl">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="editModalLabel">글 수정</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="editPostId" />
          <div class="mb-3">
            <label for="editTitle" class="form-label">제목</label>
            <input type="text" class="form-control" id="editTitle" placeholder="제목을 입력하세요" />
          </div>
          <div class="mb-3">
            <label for="editContentEditor" class="form-label">내용</label>
            <div id="editContentEditor"></div>
          </div>
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
          <button type="button" class="btn btn-success" id="updatePostBtn">수정하기</button>
        </div>
      </div>
    </div>
  </div>

  <!-- [댓글 삭제 확인 모달] -->
  <div class="modal fade" id="deleteCommentModal" tabindex="-1" aria-labelledby="deleteCommentModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="deleteCommentModalLabel">댓글 삭제</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p>해당 댓글을 삭제하시겠습니까?</p>
          <input type="hidden" id="deleteCommentPostId" />
          <input type="hidden" id="deleteCommentId" />
        </div>
        <div class="modal-footer">
          <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
          <button type="button" class="btn btn-danger" id="confirmDeleteCommentBtn">삭제</button>
        </div>
      </div>
    </div>
  </div>

  <!-- 회원가입 모달 -->
  <div class="modal fade" id="signupModal" tabindex="-1" aria-labelledby="signupModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <form id="signupForm">
          <div class="modal-header">
            <h5 class="modal-title" id="signupModalLabel">회원가입</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="mb-3">
              <label for="signupEmail" class="form-label">이메일</label>
              <input type="email" class="form-control" id="signupEmail" required />
              <small class="text-muted">올바른 이메일을 입력하면 비밀번호를 잊어버려도 계정을 찾을 수 있어요!</small>
            </div>
            <div class="mb-3">
              <label for="signupPassword" class="form-label">비밀번호</label>
              <input type="password" class="form-control" id="signupPassword" required />
            </div>
            <div class="mb-3">
              <label for="signupNickname" class="form-label">닉네임</label>
              <input type="text" class="form-control" id="signupNickname" required />
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
            <button type="submit" class="btn btn-success">회원가입</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- 로그인 모달 -->
  <div class="modal fade" id="loginModal" tabindex="-1" aria-labelledby="loginModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <form id="loginForm">
          <div class="modal-header">
            <h5 class="modal-title" id="loginModalLabel">로그인</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <div class="mb-3">
              <label for="loginEmail" class="form-label">이메일</label>
              <input type="email" class="form-control" id="loginEmail" required />
            </div>
            <div class="mb-3">
              <label for="loginPassword" class="form-label">비밀번호</label>
              <input type="password" class="form-control" id="loginPassword" required />
            </div>
            <div class="text-end">
              <button type="button" id="resetPasswordBtn" class="btn btn-link btn-sm">비밀번호 찾기</button>
            </div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
            <button type="submit" class="btn btn-primary">로그인</button>
          </div>
        </form>
      </div>
    </div>
  </div>

  <!-- [계급 안내 모달] -->
  <div class="modal fade" id="rankModal" tabindex="-1" aria-labelledby="rankModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="rankModalLabel">내 계급 안내</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <p><strong>내 점수</strong>: <span id="myScore">로딩중...</span></p>
          <p><strong>내 계급</strong>: <span id="myRank">로딩중...</span></p>
          <hr/>
          <h6>계급 기준</h6>
          <ul style="font-size:0.95rem;" id="futureMagicList"><!-- 동적 채움 --></ul>
          <small class="text-muted">
            행동별 점수: 글쓰기 +50, 댓글 +20, 좋아요 +10, 싫어요 -5
          </small>
          <div class="mt-3">
            <button class="btn btn-secondary btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#accountCollapse" aria-expanded="false" aria-controls="accountCollapse">
              계정 관리
            </button>
            <div class="collapse mt-2" id="accountCollapse">
              <div class="card card-body">
                <button id="deleteAccountBtn" class="btn btn-danger btn-sm">회원탈퇴</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- [랭킹 모달] -->
  <div class="modal fade" id="rankingModal" tabindex="-1" aria-labelledby="rankingModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="rankingModalLabel">랭킹</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="rankingContainer" style="max-height: 70vh; overflow-y: auto;">
          <!-- Firestore users 랭킹 항목들이 무한 스크롤로 로드됩니다 -->
        </div>
      </div>
    </div>
  </div>

  <!-- [마법 모달] -->
  <div class="modal fade" id="magicModal" tabindex="-1" aria-labelledby="magicModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="magicModalLabel">마법 사용</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body">
          <input type="hidden" id="magicPostId" />
          <div id="magicInfo"><!-- 동적 채움 --></div>
        </div>
        <div class="modal-footer" id="magicModalFooter">
          <!-- 버튼은 상황에 따라 동적으로 생성됩니다 -->
        </div>
      </div>
    </div>
  </div>

  <!-- Toast (알림) -->
  <div class="toast-container">
    <div id="liveToast" class="toast align-items-center dark-bg" role="alert" aria-live="assertive" aria-atomic="true">
      <div class="toast-header">
        <strong class="me-auto" id="toastTitle">알림</strong>
        <small class="text-muted" id="toastTime"></small>
        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
      <div class="toast-body" id="toastMessage">메시지 내용</div>
    </div>
  </div>

  <!-- canvas-confetti -->
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Firebase ES Modules (모듈 방식) -->
  <script type="module">
    /********************************
     * Firebase 초기화 및 모듈 임포트
     ********************************/
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.2.0/firebase-app.js';
    import { initializeAppCheck, ReCaptchaV3Provider } from 'https://www.gstatic.com/firebasejs/11.2.0/firebase-app-check.js';
    import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut, onAuthStateChanged, sendPasswordResetEmail, deleteUser } from 'https://www.gstatic.com/firebasejs/11.2.0/firebase-auth.js';
    import { getFirestore, collection, doc, setDoc, getDoc, updateDoc, deleteDoc, runTransaction, serverTimestamp, arrayUnion, arrayRemove, where, query, orderBy, getDocs, startAfter, limit, onSnapshot, Timestamp, deleteField } from 'https://www.gstatic.com/firebasejs/11.2.0/firebase-firestore.js';

    const firebaseConfig = {
      apiKey: "AIzaSyC-etI5o4uWbBp2Arj9KpxdDyRebguErnY",
      authDomain: "newpro-4bc73.firebaseapp.com",
      projectId: "newpro-4bc73",
      storageBucket: "newpro-4bc73.firebasestorage.app",
      messagingSenderId: "267192611563",
      appId: "1:267192611563:web:94fb5ec97872cd452a84ae"
    };

    const app = initializeApp(firebaseConfig);
    initializeAppCheck(app, {
      provider: new ReCaptchaV3Provider('6LcKb8QqAAAAAKReI1hvkatzxiNvquuoryudyXi4'),
      isTokenAutoRefreshEnabled: true
    });
    const auth = getAuth(app);
    const db = getFirestore(app);

    /********************************
     * 전역 사용자 캐시 및 함수
     ********************************/
    const userCache = {}; // uid별 캐시
    async function fetchUserDoc(uid) {
      if (userCache[uid]) {
        return { exists: () => true, data: () => userCache[uid] };
      }
      const userRef = doc(db, 'users', uid);
      const snap = await getDoc(userRef);
      if (snap.exists()) {
        userCache[uid] = snap.data();
      }
      return snap;
    }
    async function fetchUserNicknameAndScore(uid) {
      const snap = await fetchUserDoc(uid);
      if (snap.exists()) {
        const data = snap.data();
        return { nickname: data.nickname || null, score: data.score || 0 };
      }
      return { nickname: null, score: 0 };
    }

    /********************************
     * Toast UI Editor 및 DOMPurify 초기화
     ********************************/
    const { Editor } = toastui;
    const { codeSyntaxHighlight } = Editor.plugin;
    let createEditor = new Editor({
      el: document.querySelector('#editor'),
      initialEditType: 'wysiwyg',
      previewStyle: 'vertical',
      plugins: [codeSyntaxHighlight]
    });
    let editEditor = new Editor({
      el: document.querySelector('#editContentEditor'),
      initialEditType: 'wysiwyg',
      previewStyle: 'vertical',
      plugins: [codeSyntaxHighlight]
    });

    let quizQuestionsAll;

    function createQuizCard() {
      const card = document.createElement('div');
      card.className = 'card glass-card mb-3 quiz-card';
      card.continueClicks = 0; // "계속" 버튼 클릭 횟수
      card.currentPoints = 1;  // 초기 누적 포인트: 1점

      const cardBody = document.createElement('div');
      cardBody.className = 'card-body';
      card.appendChild(cardBody);

      function loadQuiz() {
        cardBody.innerHTML = '';
        var quiz = quizQuestionsAll[Math.floor(Math.random() * quizQuestionsAll.length)];
        cardBody.innerHTML = `
          <div>
            <h5 class="card-title" style="display: inline;">퀴즈 타임!</h5>
            <span class="quiz-points badge bg-info" style="margin-left: 10px;">누적 ${card.currentPoints}점</span>
          </div>
          <p class="card-text quiz-question">${quiz.question}</p>
          <div class="quiz-options mb-3"></div>
          <p class="quiz-result text-info" style="display: inline;"></p>
        `;
        const optionsDiv = cardBody.querySelector('.quiz-options');
        const resultEl = cardBody.querySelector('.quiz-result');

        let options = quiz.options.slice();
        options = shuffleArray(options);

        options.forEach(function(option) {
          const btn = document.createElement('button');
          btn.className = 'btn btn-outline-primary quiz-option';
          btn.textContent = option;
          btn.addEventListener('click', function() {
            // 모든 선택지 버튼 비활성화
            optionsDiv.querySelectorAll('button').forEach(b => b.disabled = true);
            if (option === quiz.answer) {
              // 정답 시, "정답입니다! 2점"처럼 표시 (현재 누적 포인트 대신 현재 문제에 추가될 포인트만 표시)
              resultEl.innerHTML = `정답입니다! 누적점수: ${card.currentPoints}점 `;
              const continueBtn = document.createElement('button');
              continueBtn.className = 'btn btn-primary btn-sm';
              continueBtn.textContent = '계속';
              continueBtn.style.marginLeft = '10px';
              const confirmBtn = document.createElement('button');
              confirmBtn.className = 'btn btn-success btn-sm';
              confirmBtn.textContent = '확정';
              confirmBtn.style.marginLeft = '5px';

              continueBtn.addEventListener('click', function() {
                card.continueClicks++;
                let newPoints = Math.pow(2, card.continueClicks);
                card.currentPoints = Math.min(newPoints, 50);
                loadQuiz();
              });

              confirmBtn.addEventListener('click', async function() {
                await awardQuizPoints(card.currentPoints);
                resultEl.innerHTML = `확정하였습니다! ${card.currentPoints}점 획득!`;
                // 확정 후에도 선택지는 그대로 남아 있음.
              });

              if(card.currentPoints < 50) {
                resultEl.appendChild(continueBtn);
              }
              resultEl.appendChild(confirmBtn);
            } else {
              resultEl.innerHTML = `오답입니다. 정답은: ${quiz.answer}`;
              card.continueClicks = 0;
              card.currentPoints = 1;
            }
          });
          optionsDiv.appendChild(btn);
        });
      }

      loadQuiz();
      return card;
    }

    async function awardQuizPoints(points) {
      const user = auth.currentUser;
      if (!user) {
        showToast("로그인이 필요합니다.", "오류");
        return;
      }
      try {
        await runTransaction(db, async (transaction) => {
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          transaction.update(userRef, { score: oldScore + points });
        });
        showToast(`퀴즈 포인트 ${points}점 획득!`, "퀴즈 챌린지");
      } catch (err) {
        showToast(err.message, "오류");
      }
    }

    function shuffleArray(array) {
      for (var i = array.length - 1; i > 0; i--) {
        var j = Math.floor(Math.random() * (i + 1));
        var temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }
      return array;
    }

    /********************************
     * 날짜/시간 포맷 함수
     ********************************/
    function formatDateTime(timestamp) {
      if (!timestamp || !timestamp.seconds) return '';
      const date = new Date(timestamp.seconds * 1000);
      let year = date.getFullYear(), month = date.getMonth() + 1, day = date.getDate();
      let hours = date.getHours(), minutes = date.getMinutes(), seconds = date.getSeconds();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12; hours = hours === 0 ? 12 : hours;
      minutes = minutes.toString().padStart(2, '0'); seconds = seconds.toString().padStart(2, '0');
      return `${year}.${month}.${day}, ${hours}:${minutes}:${seconds} ${ampm}`;
    }
    function formatDateForToast(date) {
      let year = date.getFullYear(), month = date.getMonth() + 1, day = date.getDate();
      let hours = date.getHours(), minutes = date.getMinutes(), seconds = date.getSeconds();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      hours = hours % 12; hours = hours === 0 ? 12 : hours;
      minutes = minutes.toString().padStart(2, '0'); seconds = seconds.toString().padStart(2, '0');
      return `${year}.${month}.${day}, ${hours}:${minutes}:${seconds} ${ampm}`;
    }

    /********************************
     * Toast 함수
     ********************************/
    function showToast(message, title = '알림') {
      const toastEl = document.getElementById('liveToast');
      const toastTitle = document.getElementById('toastTitle');
      const toastMessage = document.getElementById('toastMessage');
      const toastTime = document.getElementById('toastTime');
      toastTitle.textContent = title;
      toastMessage.textContent = message;
      toastTime.textContent = formatDateForToast(new Date());
      const bsToast = new bootstrap.Toast(toastEl);
      bsToast.show();
    }

    /********************************
     * DOM 요소 참조
     ********************************/
    const authLoadingBtn = document.getElementById('authLoadingBtn');
    const loginBtn = document.getElementById('loginBtn');
    const signupBtn = document.getElementById('signupBtn');
    // 기존 logoutBtn는 제거하고 드롭다운에서 처리함
    const togglePostFormBtn = document.getElementById('togglePostFormBtn');
    const showRankBtn = document.getElementById('showRankBtn');
    const postCard = document.getElementById('postCard');
    const savePostBtn = document.getElementById('savePostBtn');
    const postList = document.getElementById('postList');
    const signupForm = document.getElementById('signupForm');
    const signupEmail = document.getElementById('signupEmail');
    const signupPassword = document.getElementById('signupPassword');
    const signupNickname = document.getElementById('signupNickname');
    const loginForm = document.getElementById('loginForm');
    const loginEmail = document.getElementById('loginEmail');
    const loginPassword = document.getElementById('loginPassword');
    const resetPasswordBtn = document.getElementById('resetPasswordBtn');
    const postTitle = document.getElementById('postTitle');
    const editModalEl = document.getElementById('editModal');
    const editModal = new bootstrap.Modal(editModalEl);
    const editPostId = document.getElementById('editPostId');
    const editTitle = document.getElementById('editTitle');
    const updatePostBtn = document.getElementById('updatePostBtn');
    const deleteCommentModalEl = document.getElementById('deleteCommentModal');
    const deleteCommentModal = new bootstrap.Modal(deleteCommentModalEl);
    const deleteCommentPostId = document.getElementById('deleteCommentPostId');
    const deleteCommentId = document.getElementById('deleteCommentId');
    const confirmDeleteCommentBtn = document.getElementById('confirmDeleteCommentBtn');
    const rankModalEl = document.getElementById('rankModal');
    const myScoreEl = document.getElementById('myScore');
    const myRankEl = document.getElementById('myRank');
    const deleteAccountBtn = document.getElementById('deleteAccountBtn');
    const noticeContainer = document.getElementById('noticeContainer');

    /********************************
     * 전역 상태 변수
     ********************************/
    let currentNickname = null;
    let currentScore = 0;
    let commentUnsubscribers = {};

    function clearPostList() {
      Object.values(commentUnsubscribers).forEach(unsub => unsub());
      commentUnsubscribers = {};
      postList.innerHTML = '';
      lastVisible = null;
    }

    /********************************
     * 계급(Rank) 계산 및 마법 관련 함수
     ********************************/
    function getRankByScore(score) {
      if (score >= 50000) return { name: '이터널', icon: '🌌' };
      else if (score >= 25000) return { name: '레전드', icon: '👑' };
      else if (score >= 10000) return { name: '마스터', icon: '🏆' };
      else if (score >= 5000) return { name: '다이아몬드', icon: '💎' };
      else if (score >= 1000) return { name: '플래티넘', icon: '🛡️' };
      else if (score >= 500) return { name: '골드', icon: '🥇' };
      else if (score >= 100) return { name: '실버', icon: '🥈' };
      else return { name: '브론즈', icon: '🥉' };
    }
    function getAvailableMagicTypes(rankName) {
      switch(rankName) {
        case '브론즈': return ['magic-basic'];
        case '실버': return ['magic-basic', 'magic-shimmer'];
        case '골드': return ['magic-basic', 'magic-shimmer', 'magic-blessing'];
        case '플래티넘': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse'];
        case '다이아몬드': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse', 'magic-font'];
        case '마스터': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse', 'magic-font', 'magic-title'];
        case '레전드': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse', 'magic-font', 'magic-title', 'magic-rainbow'];
        case '이터널': return ['magic-basic', 'magic-shimmer', 'magic-blessing', 'magic-curse', 'magic-font', 'magic-title', 'magic-rainbow', 'magic-ultimate'];
        default: return ['magic-basic'];
      }
    }
    const magicDisplayNames = {
      'magic-basic': '기본 마법',
      'magic-shimmer': '반짝이는 마법',
      'magic-blessing': '축복의 마법',
      'magic-curse': '저주의 마법',
      'magic-font': '글꼴 변경 마법',
      'magic-title': '글자 뒤집기 마법',
      'magic-rainbow': '무지개 마법',
      'magic-ultimate': '궁극의 마법'
    };
    function decodeHtml(html) {
      const txt = document.createElement("textarea");
      txt.innerHTML = html;
      return txt.value;
    }
    function parseTimeParameter(timeStr) {
      let seconds = 0;
      const hMatch = timeStr.match(/(\d+)h/);
      if (hMatch) seconds += parseInt(hMatch[1], 10) * 3600;
      const mMatch = timeStr.match(/(\d+)m/);
      if (mMatch) seconds += parseInt(mMatch[1], 10) * 60;
      const sMatch = timeStr.match(/(\d+)s/);
      if (sMatch) seconds += parseInt(sMatch[1], 10);
      if (!hMatch && !mMatch && !sMatch && /^\d+$/.test(timeStr)) seconds = parseInt(timeStr, 10);
      return seconds;
    }
    function convertYouTubeLinks(text) {
      // 이미 iframe 태그가 있다면 변환하지 않고 원본 반환
      if (/(&lt;iframe|<iframe)/i.test(text)) return text;

      return text.replace(
        /(?:https?:\/\/)?(?:www\.)?(?:(?:youtu\.be\/)|(?:youtube\.com\/(?:watch\?v=|shorts\/)))([A-Za-z0-9_-]{11})([^<\s]*)/g,
        (match, videoId, params) => {
          let startParam = '';
          if (params) {
            // HTML 이스케이프된 &amp;를 실제 &로 복원하고, 앞부분의 ? 또는 &를 제거
            const queryString = params.replace(/&amp;/g, '&').replace(/^[\?&]/, '');
            const searchParams = new URLSearchParams(queryString);
            const t = searchParams.get('t');
            if (t) {
              const seconds = parseTimeParameter(t);
              startParam = `?start=${seconds}`;
            }
          }
          return `<div class="video-responsive">
                    <iframe width="560" height="315" 
                            src="https://www.youtube.com/embed/${videoId}${startParam}" 
                            frameborder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            allowfullscreen>
                    </iframe>
                  </div>`;
        }
      );
    }
    function convertLinks(text) {
      return text.replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>');
    }

    /********************************
     * 공지사항 로드
     ********************************/
    async function fetchActiveNotices() {
      const now = new Date();
      const q = query(
        collection(db, 'notices'),
        where('startDate', '<=', now),
        where('endDate', '>=', now),
        orderBy('startDate', 'desc')
      );
      let celebrating = false;
      const snapshot = await getDocs(q);
      noticeContainer.innerHTML = '';
      for (const docSnap of snapshot.docs) {
        const data = docSnap.data();
        const bannerEl = document.createElement('div');
        bannerEl.classList.add('notice-banner');
        bannerEl.textContent = data.content;
        if (data.content.includes('🎉')) {
          bannerEl.addEventListener('click', launchFireworks);
          celebrating = true;
        }
        noticeContainer.appendChild(bannerEl);
      }
      if (celebrating) launchFireworks();
    }

    /********************************
     * 회원가입, 로그인, 비밀번호 초기화, 로그아웃
     ********************************/
    signupForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const emailVal = signupEmail.value.trim();
      const pwVal = signupPassword.value.trim();
      const nickVal = signupNickname.value.trim();
      if (!emailVal || !pwVal || !nickVal) {
        showToast('모든 항목을 입력하세요.', '회원가입 실패');
        return;
      }
      try {
        const userCredential = await createUserWithEmailAndPassword(auth, emailVal, pwVal);
        const user = userCredential.user;
        await setDoc(doc(db, 'users', user.uid), {
          nickname: nickVal,
          score: 0,
          createdAt: serverTimestamp()
        });
        showToast('회원가입 성공!', '회원가입');
        bootstrap.Modal.getInstance(document.getElementById('signupModal')).hide();
        location.reload();
      } catch (err) {
        showToast(err.message, '회원가입 실패');
      }
    });
    loginForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const emailVal = loginEmail.value.trim();
      const pwVal = loginPassword.value.trim();
      if (!emailVal || !pwVal) {
        showToast('이메일/비밀번호를 입력하세요.', '로그인 실패');
        return;
      }
      try {
        await signInWithEmailAndPassword(auth, emailVal, pwVal);
        showToast('로그인 성공!', '로그인');
        bootstrap.Modal.getInstance(document.getElementById('loginModal')).hide();
        location.reload();
      } catch (err) {
        showToast(err.message, '로그인 실패');
      }
    });
    resetPasswordBtn.addEventListener('click', async () => {
      const emailVal = loginEmail.value.trim();
      if (!emailVal) {
        showToast('이메일을 입력하세요.', '오류');
        return;
      }
      if (confirm(`${emailVal}로 비밀번호 초기화 메일을 보내시겠습니까?`)) {
        try {
          await sendPasswordResetEmail(auth, emailVal);
          showToast('비밀번호 초기화 메일을 보냈습니다.', '비밀번호 초기화');
        } catch (err) {
          showToast(err.message, '오류');
        }
      }
    });
    // 기존 logoutBtn 이벤트 리스너는 제거하고 아래에서 드롭다운 로그아웃 이벤트를 추가합니다.
    onAuthStateChanged(auth, async (user) => {
      authLoadingBtn.classList.add('d-none');
      if (user) {
        loginBtn.classList.add('d-none');
        signupBtn.classList.add('d-none');
        document.getElementById('userDropdown').classList.remove('d-none');
        togglePostFormBtn.classList.remove('d-none');
        const userData = await fetchUserNicknameAndScore(user.uid);
        currentNickname = userData.nickname;
        currentScore = userData.score;
        const rankInfo = getRankByScore(currentScore);
        document.getElementById('userDropdownMenuButton').innerText = `${currentNickname} ${rankInfo.icon}`;
      } else {
        loginBtn.classList.remove('d-none');
        signupBtn.classList.remove('d-none');
        document.getElementById('userDropdown').classList.add('d-none');
        togglePostFormBtn.classList.add('d-none');
        postCard.classList.add('d-none');
        currentNickname = null;
        currentScore = 0;
      }
      const commentForms = document.querySelectorAll('[id^="commentForm-"]');
      if (user) {
        commentForms.forEach(form => form.classList.remove('d-none'));
      } else {
        commentForms.forEach(form => form.classList.add('d-none'));
      }
    });
    // 드롭다운의 로그아웃 버튼 이벤트 처리
    document.getElementById('logoutBtnDropdown').addEventListener('click', async () => {
      try {
        await signOut(auth);
        showToast('로그아웃 완료', '로그아웃');
        location.reload();
      } catch (error) {
        showToast(error.message, '로그아웃 실패');
      }
    });
    togglePostFormBtn.addEventListener('click', () => {
      postCard.classList.toggle('d-none');
      if (!postCard.classList.contains('d-none')) {
        postTitle.focus();
      }
    });

    rankModalEl.addEventListener('show.bs.modal', async () => {
      const futureMagicListEl = document.getElementById('futureMagicList');
      if (!auth.currentUser) {
        myScoreEl.textContent = '(로그인 필요)';
        myRankEl.textContent = '-';
      } else {
        const snap = await getDoc(doc(db, 'users', auth.currentUser.uid));
        if (snap.exists()) {
          const data = snap.data();
          userCache[auth.currentUser.uid] = data;
          currentScore = data.score || 0;
          currentNickname = data.nickname || null;
        }
        myScoreEl.textContent = `${currentScore}점`;
        const rankInfo = getRankByScore(currentScore);
        myRankEl.textContent = `${rankInfo.name} ${rankInfo.icon}`;
      }
      const lastMagicTypes = getAvailableMagicTypes('이터널');
      const rankMagicMapping = [
        { rank: '브론즈', icon: '🥉', range: '0~99' },
        { rank: '실버', icon: '🥈', range: '100~499' },
        { rank: '골드', icon: '🥇', range: '500~999' },
        { rank: '플래티넘', icon: '🛡️', range: '1,000~4,999' },
        { rank: '다이아몬드', icon: '💎', range: '5,000~9,999' },
        { rank: '마스터', icon: '🏆', range: '10,000~24,999' },
        { rank: '레전드', icon: '👑', range: '25,000~49,999' },
        { rank: '이터널', icon: '🌌', range: '50,000+' }
      ];
      let futureMagicHTML = '';
      rankMagicMapping.forEach((mapping, i) => {
        mapping.magic = [ lastMagicTypes[i] ];
        const magicList = mapping.magic.map(type => magicDisplayNames[type] || type).join(', ');
        futureMagicHTML += `<li>${mapping.icon} ${mapping.rank} (${mapping.range}): ${magicList}</li>`;
      });
      futureMagicListEl.innerHTML = futureMagicHTML;
    });

    /********************************
     * 글 작성 (DOMPurify 및 유튜브 임베디드 적용)
     ********************************/
    savePostBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      if (!currentNickname) {
        showToast('닉네임을 불러오지 못했습니다.', '오류');
        return;
      }
      const titleVal = DOMPurify.sanitize(postTitle.value.trim(), { ALLOWED_TAGS: [] });
      const contentVal = createEditor ? createEditor.getHTML() : '';
      if (!titleVal) {
        showToast('제목을 입력하세요.', '오류');
        return;
      }
      if (!contentVal.trim()) {
        showToast('내용을 입력하세요.', '오류');
        return;
      }
      try {
        await runTransaction(db, async (transaction) => {
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          const newPostRef = doc(collection(db, 'posts'));
          transaction.set(newPostRef, {
            uid: user.uid,
            nickname: currentNickname,
            title: titleVal,
            content: contentVal,
            createdAt: serverTimestamp(),
            likes: [],
            dislikes: []
          });
          transaction.update(userRef, { score: oldScore + 50 });
        });
        showToast('글이 등록되었습니다.', '글 작성');
        postTitle.value = '';
        createEditor.setHTML('');
        postCard.classList.add('d-none');
        clearPostList();
        await loadMorePosts();
        const userData = await fetchUserNicknameAndScore(user.uid);
        currentScore = userData.score;
      } catch (err) {
        showToast(err.message, '글 작성 실패');
      }
    });

    /********************************
     * 글 수정 및 삭제
     ********************************/
    async function openEditModal(postDoc) {
      editPostId.value = postDoc.id;
      editTitle.value = postDoc.data().title;
      if (editEditor) editEditor.setHTML(postDoc.data().content);
      editModal.show();
    }
    updatePostBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const docId = editPostId.value;
      const newTitle = editTitle.value.trim();
      const newContent = editEditor ? editEditor.getHTML() : '';
      if (!newTitle || !newContent.trim()) {
        showToast('제목과 내용을 입력하세요.', '오류');
        return;
      }
      try {
        const postRef = doc(db, 'posts', docId);
        const postSnap = await getDoc(postRef);
        if (!postSnap.exists()) {
          showToast('존재하지 않는 글입니다.', '오류');
          return;
        }
        if (postSnap.data().uid !== user.uid) {
          showToast('본인 글만 수정할 수 있습니다.', '오류');
          return;
        }
        await updateDoc(postRef, { title: newTitle, content: newContent });
        showToast('글이 수정되었습니다.', '성공');
        editModal.hide();
        clearPostList();
        await loadMorePosts();
      } catch (err) {
        showToast(err.message, '수정 실패');
      }
    });
    async function deletePost(postDoc) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const postData = postDoc.data();
      if (postData.uid !== user.uid) {
        showToast('본인 글만 삭제할 수 있습니다.', '오류');
        return;
      }
      if (!confirm('이 글을 삭제하시겠습니까?')) return;
      try {
        await deleteDoc(postDoc.ref);
        showToast('글이 삭제되었습니다.', '삭제');
        clearPostList();
        await loadMorePosts();
      } catch (err) {
        showToast(err.message, '삭제 실패');
      }
    }

    /********************************
     * 댓글 등록 (부모 댓글 ID 선택적)
     ********************************/
    async function addComment(postId, content, parentCommentId = null) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const sanitizedContent = DOMPurify.sanitize(content, { ALLOWED_TAGS: [] });
      if (!sanitizedContent.trim()) {
        showToast('댓글 내용을 입력하세요.', '오류');
        return;
      }
      try {
        await runTransaction(db, async (transaction) => {
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          const cmtRef = doc(collection(db, 'posts', postId, 'comments'));
          transaction.set(cmtRef, {
            uid: user.uid,
            nickname: currentNickname,
            content: sanitizedContent,
            createdAt: serverTimestamp(),
            parentCommentId: parentCommentId || null,
            likes: [],
            dislikes: []
          });
          transaction.update(userRef, { score: oldScore + 20 });
        });
        showToast('댓글이 등록되었습니다.', '댓글 작성');
      } catch (err) {
        showToast(err.message, '댓글 등록 실패');
      }
    }

    /********************************
     * 댓글 삭제
     ********************************/
    function openDeleteCommentModal(postId, commentId) {
      deleteCommentPostId.value = postId;
      deleteCommentId.value = commentId;
      deleteCommentModal.show();
    }
    confirmDeleteCommentBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const postId = deleteCommentPostId.value;
      const commentId = deleteCommentId.value;
      try {
        const commentRef = doc(db, 'posts', postId, 'comments', commentId);
        const commentSnap = await getDoc(commentRef);
        if (!commentSnap.exists()) {
          showToast('존재하지 않는 댓글입니다.', '오류');
          return;
        }
        if (commentSnap.data().uid !== user.uid) {
          showToast('본인 댓글만 삭제할 수 있습니다.', '오류');
          return;
        }
        await deleteDoc(commentRef);
        showToast('댓글이 삭제되었습니다.', '댓글 삭제');
        deleteCommentModal.hide();
      } catch (err) {
        showToast(err.message, '댓글 삭제 실패');
      }
    });

    /********************************
     * 댓글 렌더링 (계층구조 처리)
     ********************************/
     async function renderComments(postId, comments, containerEl) {
      containerEl.innerHTML = '';
      const header = document.getElementById(`commentHeader-${postId}`);
      if (comments.length === 0) {
        if (header) header.style.display = 'none';
      } else {
        if (header) header.style.display = '';
      }
      const commentMap = {};
      comments.forEach(c => {
        c.children = [];
        commentMap[c.commentId] = c;
      });
      const roots = [];
      comments.forEach(c => {
        if (c.parentCommentId && commentMap[c.parentCommentId]) {
          commentMap[c.parentCommentId].children.push(c);
        } else {
          roots.push(c);
        }
      });

      function isOnlyEmoji(text) {
        const trimmed = text.trim();
        // 정규표현식: 텍스트가 단일 이모지(필수적으로 FE0F 선택적 포함)만 포함하는지 검사
        const regex = /^(?:\p{Extended_Pictographic}(?:\uFE0F)?)$/u;
        return regex.test(trimmed);
      }

      function renderCommentNode(comment, indent = 0) {
        let rankIcon = '';
        let commentNickname = comment.nickname || '익명';
        const div = document.createElement('div');
        div.className = 'comment-item';
        // indent는 rem 단위로 적용되며, 최대 2rem까지만 들여쓰기합니다.
        div.style.marginLeft = indent + 'rem';

        const safeContent = DOMPurify.sanitize(comment.content ?? '', { ALLOWED_TAGS: [] });
        let finalContent;
        if (isOnlyEmoji(safeContent)) {
          finalContent = `<span class="emoji-large">${safeContent}</span>`;
        } else {
          finalContent = convertLinks(safeContent);
        }
        const dateStr = formatDateTime(comment.createdAt);

        // 최상위 댓글(indent가 0인 경우)에만 답글 버튼과 폼을 노출
        const replyButtonHtml = indent === 0
          ? `<button class="btn btn-sm btn-link" id="replyBtn-${postId}-${comment.commentId}">답글</button>`
          : '';
        const replyFormHtml = indent === 0
          ? `<div class="reply-form d-none" id="replyForm-${postId}-${comment.commentId}">
              <textarea class="form-control mb-2" rows="2" placeholder="댓글을 입력하세요" id="replyInput-${postId}-${comment.commentId}"></textarea>
              <button class="btn btn-secondary btn-sm" id="replySubmitBtn-${postId}-${comment.commentId}">댓글 달기</button>
            </div>`
          : '';

        div.innerHTML = `
          <div class="fw-bold">
            ${commentNickname} <span style="cursor:pointer;" id="commentRankIcon-${postId}-${comment.commentId}">${rankIcon}</span>
          </div>
          <div class="small text-muted mb-1">
            ${dateStr}
          </div>
          <div class="keep-line-breaks">${finalContent}</div>
          <div class="mt-1 d-flex align-items-center gap-2">
            <button class="btn btn-sm btn-outline-primary" id="commentLikeBtn-${postId}-${comment.commentId}">👍</button>
            <span id="commentLikeCount-${postId}-${comment.commentId}">${comment.likes ? comment.likes.length : 0}</span>
            <button class="btn btn-sm btn-outline-danger" id="commentDislikeBtn-${postId}-${comment.commentId}">👎</button>
            <span id="commentDislikeCount-${postId}-${comment.commentId}">${comment.dislikes ? comment.dislikes.length : 0}</span>            
            ${auth.currentUser && auth.currentUser.uid === comment.uid ? `<button id="delBtn-${postId}-${comment.commentId}" class="btn btn-sm btn-danger ms-2">삭제</button>` : ''}
            ${replyButtonHtml}
          </div>
          ${replyFormHtml}
        `;

        // --- 추가된 부분: 현재 사용자가 이미 좋아요/싫어요 한 경우 버튼 활성화 처리 --- 
        if (auth.currentUser) {
          const userId = auth.currentUser.uid;
          const commentLikeBtn = div.querySelector(`#commentLikeBtn-${postId}-${comment.commentId}`);
          const commentDislikeBtn = div.querySelector(`#commentDislikeBtn-${postId}-${comment.commentId}`);
          if (comment.likes && comment.likes.includes(userId)) {
            commentLikeBtn.classList.remove('btn-outline-primary');
            commentLikeBtn.classList.add('btn-primary');
          }
          if (comment.dislikes && comment.dislikes.includes(userId)) {
            commentDislikeBtn.classList.remove('btn-outline-danger');
            commentDislikeBtn.classList.add('btn-danger');
          }
        }
        // ---------------------------------------------------------------------------

        // 삭제 버튼 이벤트
        const delBtn = div.querySelector(`#delBtn-${postId}-${comment.commentId}`);
        if (delBtn) {
          delBtn.addEventListener('click', () => {
            openDeleteCommentModal(postId, comment.commentId);
          });
        }

        // 좋아요 / 싫어요 버튼 이벤트
        const commentLikeBtn = div.querySelector(`#commentLikeBtn-${postId}-${comment.commentId}`);
        const commentDislikeBtn = div.querySelector(`#commentDislikeBtn-${postId}-${comment.commentId}`);
        commentLikeBtn.addEventListener('click', () => {
          toggleCommentLike(postId, comment.commentId)
        });
        commentDislikeBtn.addEventListener('click', () => toggleCommentDislike(postId, comment.commentId));

        // 답글 버튼과 폼은 indent가 0인 경우(최상위 댓글)일 때만 이벤트를 등록합니다.
        if (indent === 0) {
          const replyBtn = div.querySelector(`#replyBtn-${postId}-${comment.commentId}`);
          const replyForm = div.querySelector(`#replyForm-${postId}-${comment.commentId}`);
          replyBtn.addEventListener('click', () => {
            replyForm.classList.toggle('d-none');
          });
          const replySubmitBtn = div.querySelector(`#replySubmitBtn-${postId}-${comment.commentId}`);
          replySubmitBtn.addEventListener('click', () => {
            const replyInput = div.querySelector(`#replyInput-${postId}-${comment.commentId}`);
            const text = replyInput.value.trim();
            if (text) {
              addComment(postId, text, comment.commentId);
              replyInput.value = '';
              replyForm.classList.add('d-none');
            }
          });
        }

        // 계급 아이콘 설정
        const rankIconEl = div.querySelector(`#commentRankIcon-${postId}-${comment.commentId}`);
        if (comment.uid) {
          fetchUserDoc(comment.uid).then(snap => {
            if (snap.exists()) {
              const userData = snap.data();
              const userScore = userData.score || 0;
              const rankInfo = getRankByScore(userScore);
              rankIconEl.textContent = rankInfo.icon;
              rankIconEl.addEventListener('click', () => {
                showToast(`계급: ${rankInfo.name} (${userScore}점)`, userData.nickname || '익명');
              });
            }
          });
        }

        // 자식 댓글 렌더링
        // indent가 0인 경우에만 2rem 들여쓰기로 증가하고, 그 이후엔 최대 들여쓰기를 유지합니다.
        if (comment.children && comment.children.length > 0) {
          // 최상위 댓글일 때는 indent 0 → 2, 답글인 경우는 계속 2rem을 유지
          const newIndent = indent === 0 ? indent + 2 : indent;
          comment.children.forEach(child => {
            const childDiv = renderCommentNode(child, newIndent);
            div.appendChild(childDiv);
          });
        }
        return div;
      }

      roots.forEach(comment => {
        const commentNode = renderCommentNode(comment, 0);
        containerEl.appendChild(commentNode);
      });
    }

    /********************************
     * 좋아요/싫어요 (게시글)
     ********************************/
    let likeDislikeInProgress = new Set();
    async function toggleLike(postId) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      if (likeDislikeInProgress.has(postId)) return;
      likeDislikeInProgress.add(postId);
      try {
        await runTransaction(db, async (transaction) => {
          const postRef = doc(db, 'posts', postId);
          const postSnap = await transaction.get(postRef);
          if (!postSnap.exists()) return;
          const data = postSnap.data();
          const likes = data.likes || [];
          const dislikes = data.dislikes || [];
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          let scoreDiff = 0;
          const alreadyLiked = likes.includes(user.uid);
          const alreadyDisliked = dislikes.includes(user.uid);
          if (alreadyLiked) {
            transaction.update(postRef, { likes: arrayRemove(user.uid) });
            scoreDiff -= 10;
          } else {
            transaction.update(postRef, { likes: arrayUnion(user.uid) });
            if (alreadyDisliked) {
              transaction.update(postRef, { dislikes: arrayRemove(user.uid) });
              scoreDiff += 5;
            }
            scoreDiff += 10;
          }
          transaction.update(userRef, { score: oldScore + scoreDiff });
        });
        const userData = await fetchUserNicknameAndScore(user.uid);
        currentScore = userData.score;
      } catch (err) {
        showToast(err.message, '오류');
      } finally {
        likeDislikeInProgress.delete(postId);
      }
    }
    async function toggleDislike(postId) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      if (likeDislikeInProgress.has(postId)) return;
      likeDislikeInProgress.add(postId);
      try {
        await runTransaction(db, async (transaction) => {
          const postRef = doc(db, 'posts', postId);
          const postSnap = await transaction.get(postRef);
          if (!postSnap.exists()) return;
          const data = postSnap.data();
          const likes = data.likes || [];
          const dislikes = data.dislikes || [];
          const userRef = doc(db, 'users', user.uid);
          const userSnap = await transaction.get(userRef);
          let oldScore = 0;
          if (userSnap.exists()) oldScore = userSnap.data().score || 0;
          let scoreDiff = 0;
          const alreadyLiked = likes.includes(user.uid);
          const alreadyDisliked = dislikes.includes(user.uid);
          if (alreadyDisliked) {
            transaction.update(postRef, { dislikes: arrayRemove(user.uid) });
            scoreDiff += 5;
          } else {
            transaction.update(postRef, { dislikes: arrayUnion(user.uid) });
            if (alreadyLiked) {
              transaction.update(postRef, { likes: arrayRemove(user.uid) });
              scoreDiff -= 10;
            }
            scoreDiff -= 5;
          }
          transaction.update(userRef, { score: oldScore + scoreDiff });
        });
        const userData = await fetchUserNicknameAndScore(user.uid);
        currentScore = userData.score;
      } catch (err) {
        showToast(err.message, '오류');
      } finally {
        likeDislikeInProgress.delete(postId);
      }
    }

    /********************************
     * 좋아요/싫어요 (댓글)
     ********************************/
    let commentLikeDislikeInProgress = new Set();
    async function toggleCommentLike(postId, commentId) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const key = `comment-${postId}-${commentId}`;
      if (commentLikeDislikeInProgress.has(key)) return;
      commentLikeDislikeInProgress.add(key);
      try {
        await runTransaction(db, async (transaction) => {
          const commentRef = doc(db, 'posts', postId, 'comments', commentId);
          const commentSnap = await transaction.get(commentRef);
          if (!commentSnap.exists()) return;
          const data = commentSnap.data();
          const likes = data.likes || [];
          const dislikes = data.dislikes || [];
          let scoreDiff = 0;
          const alreadyLiked = likes.includes(user.uid);
          const alreadyDisliked = dislikes.includes(user.uid);
          if (alreadyLiked) {
            transaction.update(commentRef, { likes: arrayRemove(user.uid) });
            scoreDiff -= 5;
          } else {
            transaction.update(commentRef, { likes: arrayUnion(user.uid) });
            if (alreadyDisliked) {
              transaction.update(commentRef, { dislikes: arrayRemove(user.uid) });
              scoreDiff += 3;
            }
            scoreDiff += 5;
          }
        });
      } catch (err) {
        showToast(err.message, '오류');
      } finally {
        commentLikeDislikeInProgress.delete(`comment-${postId}-${commentId}`);
      }
    }
    async function toggleCommentDislike(postId, commentId) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const key = `comment-${postId}-${commentId}`;
      if (commentLikeDislikeInProgress.has(key)) return;
      commentLikeDislikeInProgress.add(key);
      try {
        await runTransaction(db, async (transaction) => {
          const commentRef = doc(db, 'posts', postId, 'comments', commentId);
          const commentSnap = await transaction.get(commentRef);
          if (!commentSnap.exists()) return;
          const data = commentSnap.data();
          const likes = data.likes || [];
          const dislikes = data.dislikes || [];
          let scoreDiff = 0;
          const alreadyLiked = likes.includes(user.uid);
          const alreadyDisliked = dislikes.includes(user.uid);
          if (alreadyDisliked) {
            transaction.update(commentRef, { dislikes: arrayRemove(user.uid) });
            scoreDiff += 3;
          } else {
            transaction.update(commentRef, { dislikes: arrayUnion(user.uid) });
            if (alreadyLiked) {
              transaction.update(commentRef, { likes: arrayRemove(user.uid) });
              scoreDiff -= 5;
            }
            scoreDiff -= 3;
          }
        });
      } catch (err) {
        showToast(err.message, '오류');
      } finally {
        commentLikeDislikeInProgress.delete(`comment-${postId}-${commentId}`);
      }
    }

    /********************************
     * 개별 글 DOM 생성 (게시글 내용, 좋아요/싫어요, 수정/삭제, 마법, 댓글 등)
     ********************************/
    async function createPostItem(docSnap) {
      const data = docSnap.data();
      const postId = docSnap.id;
      const card = document.createElement('div');
      card.className = 'card mb-3';
      card.id = 'postCard-' + postId;
      let authorNickname = data.nickname || '익명';
      let authorRankEmoji = '';
      let authorScore = 0;
      try {
        const snap = await fetchUserDoc(data.uid);
        if (snap.exists()) {
          const userData = snap.data();
          authorScore = userData.score || 0;
          const rankInfo = getRankByScore(userData.score || 0);
          authorRankEmoji = rankInfo.icon;
          authorNickname = userData.nickname || authorNickname;
        }
      } catch (_) {}
      let isAuthor = false;
      const currentUser = auth.currentUser;
      if (currentUser && currentUser.uid === data.uid) isAuthor = true;
      const likeCount = data.likes ? data.likes.length : 0;
      const dislikeCount = data.dislikes ? data.dislikes.length : 0;
      const title = DOMPurify.sanitize(data.title, { ALLOWED_TAGS: [] });
      const finalContent = convertYouTubeLinks(data.content);
      card.innerHTML = `
        <div class="card-header fw-bold d-flex justify-content-between align-items-center">
          <span>${title}</span>
          <div class="action-buttons">
            ${isAuthor ? `
              <button class="btn btn-sm btn-warning me-2" id="editBtn-${postId}">수정</button>
              <button class="btn btn-sm btn-danger me-2" id="deleteBtn-${postId}">삭제</button>
            ` : ''}
            ${currentUser ? `<button class="btn btn-sm magic-btn" id="magicBtn-${postId}">💫</button>` : ''}
          </div>
        </div>
        <div class="card-body">
          <h6 class="card-subtitle text-muted mb-2 post-subtitle">
            <span>작성자: ${authorNickname} <span style="cursor:pointer;" id="rankIcon-${postId}">${authorRankEmoji}</span></span>
            <span>${formatDateTime(data.createdAt)}</span>
          </h6>
          <div class="card-text mt-2 toastui-editor-contents">${finalContent}</div>
          <div class="mt-3 d-flex align-items-center gap-2">
            <button class="btn btn-sm btn-outline-primary" id="likeBtn-${postId}">👍</button>
            <span id="likeCount-${postId}">${likeCount}</span>
            <button class="btn btn-sm btn-outline-danger" id="dislikeBtn-${postId}">👎</button>
            <span id="dislikeCount-${postId}">${dislikeCount}</span>
            <span class="vr mx-2"></span>
            <button class="btn btn-sm btn-outline-secondary" id="shareBtn-${postId}">🔗</button>
          </div>
          <div class="mt-3">
            <h6 id="commentHeader-${postId}">댓글</h6>
            <div id="commentList-${postId}"></div>
          </div>
          <div class="mt-2 d-none" id="commentForm-${postId}">
            <textarea class="form-control mb-2" rows="2" placeholder="댓글을 입력하세요" id="commentInput-${postId}"></textarea>
            <button class="btn btn-secondary" id="commentBtn-${postId}">댓글 달기</button>
          </div>
        </div>
      `;
      if (currentUser) {
        const magicBtn = card.querySelector(`#magicBtn-${postId}`);
        if (magicBtn) {
          magicBtn.addEventListener('click', () => {
            if (currentUser.uid !== data.uid && currentScore <= authorScore) {
              showToast("마력이 미치지 않습니다.", "마법");
              return;
            }
            openMagicModal(postId, data, authorScore);
          });
        }
      }
      if (isAuthor) {
        const editBtn = card.querySelector(`#editBtn-${postId}`);
        editBtn.addEventListener('click', async () => {
          const postSnap = await getDoc(doc(db, 'posts', postId));
          if (postSnap.exists()) openEditModal(postSnap);
          else showToast('글 정보를 불러오지 못했습니다.', '오류');
        });
        const deleteBtn = card.querySelector(`#deleteBtn-${postId}`);
        deleteBtn.addEventListener('click', async () => {
          const postSnap = await getDoc(doc(db, 'posts', postId));
          if (postSnap.exists()) await deletePost(postSnap);
        });
      }
      const likeBtn = card.querySelector(`#likeBtn-${postId}`);
      const dislikeBtn = card.querySelector(`#dislikeBtn-${postId}`);
      likeBtn.addEventListener('click', () => {
        likeBtn.classList.add('like-flame');
        toggleLike(postId);
        if (card.classList.contains('magic-ultimate')) {
          launchFireworkSpread();
        }
        setTimeout(() => {
          likeBtn.classList.remove('like-flame');
        }, 500);
      });
      dislikeBtn.addEventListener('click', () => toggleDislike(postId));
      const shareBtn = card.querySelector(`#shareBtn-${postId}`);
      shareBtn.addEventListener('click', () => {
        const shareUrl = window.location.origin + window.location.pathname + '?postId=' + postId;
        navigator.clipboard.writeText(shareUrl).then(() => {
          showToast('URL 복사되었습니다.', '공유');
        }).catch((err) => {
          showToast('URL 복사 실패: ' + err, '공유');
        });
      });
      if (currentUser) {
        if (data.likes?.includes(currentUser.uid)) {
          likeBtn.classList.remove('btn-outline-primary');
          likeBtn.classList.add('btn-primary');
        }
        if (data.dislikes?.includes(currentUser.uid)) {
          dislikeBtn.classList.remove('btn-outline-danger');
          dislikeBtn.classList.add('btn-danger');
        }
      }
      const commentListEl = card.querySelector(`#commentList-${postId}`);
      const commentFormEl = card.querySelector(`#commentForm-${postId}`);
      const commentInputEl = card.querySelector(`#commentInput-${postId}`);
      const commentBtn = card.querySelector(`#commentBtn-${postId}`);
      if (currentUser) commentFormEl.classList.remove('d-none');
      commentBtn.addEventListener('click', () => {
        const text = commentInputEl.value.trim();
        addComment(postId, text);
        commentInputEl.value = '';
      });
      const rankIconEl = card.querySelector(`#rankIcon-${postId}`);
      rankIconEl.addEventListener('click', async () => {
        try {
          const snap = await fetchUserDoc(data.uid);
          if (snap.exists()) {
            const uData = snap.data();
            const s = uData.score || 0;
            const rInfo = getRankByScore(s);
            showToast(`계급: ${rInfo.name} (${s}점)`, authorNickname);
          } else {
            showToast('유저 정보 없음', '알림');
          }
        } catch (err) {
          showToast(err.message, '알림');
        }
      });
      if (data.magic && data.magic.expiresAt) {
        const now = new Date();
        const exp = new Date(data.magic.expiresAt.seconds * 1000);
        if (now < exp) card.classList.add(data.magic.magicType);
      }
      return card;
    }

    /********************************
     * 마법 관련 함수
     ********************************/
    async function openMagicModal(postId, postData, authorScore) {
      const magicModalEl = document.getElementById('magicModal');
      const magicModal = new bootstrap.Modal(magicModalEl);
      const magicPostIdInput = document.getElementById('magicPostId');
      const magicInfoDiv = document.getElementById('magicInfo');
      const magicModalFooter = document.getElementById('magicModalFooter');
      magicPostIdInput.value = postId;
      const postRef = doc(db, 'posts', postId);
      const postSnap = await getDoc(postRef);
      const postDocData = postSnap.data();
      let magic = postDocData.magic || null;
      if (magic && magic.expiresAt) {
        const now = new Date();
        const exp = new Date(magic.expiresAt.seconds * 1000);
        if (now >= exp) magic = null;
      }
      magicInfoDiv.innerHTML = "";
      magicModalFooter.innerHTML = "";
      if (magic) {
        magicInfoDiv.innerHTML = `
          <p>현재 적용된 마법: <strong>${magicDisplayNames[magic.magicType]}</strong></p>
          <p>시전자: <strong>${magic.casterNickname || '알 수 없음'}</strong></p>
          <p>종료 시각: <strong>${magic.expiresAt ? formatDateTime(magic.expiresAt) : '알 수 없음'}</strong></p>
        `;
        const casterSnap = await getDoc(doc(db, 'users', magic.casterUid));
        const casterData = casterSnap.exists() ? casterSnap.data() : null;
        const casterScore = casterData ? (casterData.score || 0) : 0;
        if (currentScore >= casterScore) {
          const removeBtn = document.createElement('button');
          removeBtn.className = 'btn btn-danger';
          removeBtn.textContent = '마법 해제';
          removeBtn.addEventListener('click', () => removeMagic(postId));
          magicModalFooter.appendChild(removeBtn);
        }
        const closeBtn = document.createElement('button');
        closeBtn.className = 'btn btn-secondary';
        closeBtn.textContent = '닫기';
        closeBtn.setAttribute('data-bs-dismiss', 'modal');
        magicModalFooter.appendChild(closeBtn);
      } else {
        if (auth.currentUser.uid === postData.uid || currentScore > authorScore) {
          const rankInfo = getRankByScore(currentScore);
          const availableMagic = getAvailableMagicTypes(rankInfo.name);
          let radioHTML = `<p>이 글에 시전할 마법을 선택하세요:</p>`;
          availableMagic.forEach((magicType, index) => {
            const displayName = magicDisplayNames[magicType] || magicType;
            radioHTML += `
              <div class="form-check">
                <input class="form-check-input" type="radio" name="magicRadio" id="magicRadio-${magicType}" value="${magicType}" ${index===0 ? 'checked' : ''}>
                <label class="form-check-label" for="magicRadio-${magicType}">${displayName}</label>
              </div>`;
          });
          magicInfoDiv.innerHTML = radioHTML;
          const castBtn = document.createElement('button');
          castBtn.className = 'btn btn-primary';
          castBtn.textContent = '마법 시전';
          castBtn.addEventListener('click', () => {
            const radios = document.getElementsByName('magicRadio');
            let selectedMagic;
            for (let radio of radios) {
              if (radio.checked) { selectedMagic = radio.value; break; }
            }
            castMagic(postId, postData, selectedMagic);
          });
          magicModalFooter.appendChild(castBtn);
        } else {
          magicInfoDiv.innerHTML = `<p>포인트가 부족하여 마법을 시전할 수 없습니다.</p>`;
        }
        const closeBtn = document.createElement('button');
        closeBtn.className = 'btn btn-secondary';
        closeBtn.textContent = '닫기';
        closeBtn.setAttribute('data-bs-dismiss', 'modal');
        magicModalFooter.appendChild(closeBtn);
      }
      magicModal.show();
    }
    async function castMagic(postId, postData, magicType) {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인이 필요합니다.', '오류');
        return;
      }
      const durationMapping = {
        'magic-basic': 3000,
        'magic-shimmer': 3000,
        'magic-blessing': 4000,
        'magic-curse': 4000,
        'magic-font': 5000,
        'magic-title': 5000,
        'magic-rainbow': 6000,
        'magic-ultimate': 6000
      };
      const duration = durationMapping[magicType] || 300;
      const expiresAt = Timestamp.fromDate(new Date(Date.now() + duration * 1000));
      try {
        await runTransaction(db, async (transaction) => {
          const postRef = doc(db, 'posts', postId);
          const postSnap = await transaction.get(postRef);
          if (!postSnap.exists()) throw new Error('글을 찾을 수 없습니다.');
          transaction.update(postRef, {
            magic: {
              magicType: magicType,
              casterUid: user.uid,
              casterNickname: currentNickname,
              castTime: serverTimestamp(),
              duration: duration,
              expiresAt: expiresAt
            }
          });
        });
        showToast('마법이 시전되었습니다!', '마법');
        const cardEl = document.getElementById(`postCard-${postId}`);
        if (cardEl) cardEl.classList.add(magicType);
        bootstrap.Modal.getInstance(document.getElementById('magicModal')).hide();
      } catch (err) {
        showToast(err.message, '마법 시전 실패');
      }
    }
    async function removeMagic(postId) {
      try {
        await runTransaction(db, async (transaction) => {
          const postRef = doc(db, 'posts', postId);
          const postSnap = await transaction.get(postRef);
          if (!postSnap.exists()) throw new Error('글을 찾을 수 없습니다.');
          transaction.update(postRef, { magic: deleteField() });
        });
        showToast('마법이 해제되었습니다.', '마법');
        const cardEl = document.getElementById(`postCard-${postId}`);
        if (cardEl) cardEl.className = cardEl.className.replace(/\bmagic-\S+\b/g, '');
        bootstrap.Modal.getInstance(document.getElementById('magicModal')).hide();
      } catch (err) {
        showToast(err.message, '마법 해제 실패');
      }
    }

    /********************************
     * 실시간 글 UI 및 댓글 업데이트, 무한 스크롤
     ********************************/
     function updatePostUI(postSnap) {
      const postId = postSnap.id;
      const data = postSnap.data();
      const likeCountEl = document.getElementById(`likeCount-${postId}`);
      const dislikeCountEl = document.getElementById(`dislikeCount-${postId}`);
      if (likeCountEl) likeCountEl.textContent = data.likes?.length || 0;
      if (dislikeCountEl) dislikeCountEl.textContent = data.dislikes?.length || 0;
      
      // → 추가: 좋아요/싫어요 버튼 상태 업데이트
      const currentUser = auth.currentUser;
      const likeBtn = document.getElementById(`likeBtn-${postId}`);
      const dislikeBtn = document.getElementById(`dislikeBtn-${postId}`);
      if (likeBtn) {
        if (currentUser && data.likes && data.likes.includes(currentUser.uid)) {
          likeBtn.classList.remove('btn-outline-primary');
          likeBtn.classList.add('btn-primary');
        } else {
          likeBtn.classList.remove('btn-primary');
          likeBtn.classList.add('btn-outline-primary');
        }
      }
      if (dislikeBtn) {
        if (currentUser && data.dislikes && data.dislikes.includes(currentUser.uid)) {
          dislikeBtn.classList.remove('btn-outline-danger');
          dislikeBtn.classList.add('btn-danger');
        } else {
          dislikeBtn.classList.remove('btn-danger');
          dislikeBtn.classList.add('btn-outline-danger');
        }
      }
      
      // 기존의 마법 효과 및 burning 효과 처리
      const cardEl = document.getElementById(`postCard-${postId}`);
      if (cardEl) {
        if (data.magic && data.magic.expiresAt) {
          const now = new Date();
          const exp = new Date(data.magic.expiresAt.seconds * 1000);
          if (now < exp) {
            cardEl.className = cardEl.className.replace(/\bmagic-\S+\b/g, '');
            cardEl.classList.add(data.magic.magicType);
          } else {
            cardEl.className = cardEl.className.replace(/\bmagic-\S+\b/g, '');
          }
        } else {
          cardEl.className = cardEl.className.replace(/\bmagic-\S+\b/g, '');
        }
        if (data.likes && data.likes.length >= 3) {
          cardEl.classList.add('burning');
        } else {
          cardEl.classList.remove('burning');
        }
      }
    }

    let lastVisible = null;
    let isLoading = false;
    const PAGE_SIZE = 5;
    async function loadMorePosts() {
      if (isLoading) return;
      isLoading = true;
      let q = query(
        collection(db, 'posts'),
        orderBy('createdAt', 'desc'),
        limit(PAGE_SIZE)
      );
      if (lastVisible) {
        q = query(
          collection(db, 'posts'),
          orderBy('createdAt', 'desc'),
          startAfter(lastVisible),
          limit(PAGE_SIZE)
        );
      }
      const snapshot = await getDocs(q);
      if (!snapshot.empty) {
        let newLastDoc = null;
        for (let docSnap of snapshot.docs) {
          const item = await createPostItem(docSnap);

          // 퀴즈 카드 하나 삽입
          if(Math.random() < 0.2) {
            const quizCard = createQuizCard();
            postList.appendChild(quizCard);
          }

          postList.appendChild(item);
          onSnapshot(doc(db, 'posts', docSnap.id), (updatedSnap) => {
            if (updatedSnap.exists()) updatePostUI(updatedSnap);
          });
          if (!commentUnsubscribers[docSnap.id]) {
            const cmtQuery = query(
              collection(db, 'posts', docSnap.id, 'comments'),
              orderBy('createdAt', 'asc')
            );
            commentUnsubscribers[docSnap.id] = onSnapshot(cmtQuery, (cmtSnapshot) => {
              const cmtData = [];
              cmtSnapshot.forEach((cmtDoc) => {
                const cdata = cmtDoc.data();
                cdata.commentId = cmtDoc.id;
                cmtData.push(cdata);
              });
              const commentListEl = document.querySelector(`#commentList-${docSnap.id}`);
              if (commentListEl) renderComments(docSnap.id, cmtData, commentListEl);
            });
          }
          newLastDoc = docSnap;
        }
        lastVisible = newLastDoc;
      }
      isLoading = false;
    }

    window.addEventListener('scroll', () => {
      if (window.innerHeight + window.scrollY >= document.body.offsetHeight - 100) loadMorePosts();
    });

    /********************************
     * 랭킹 관련 (무한 스크롤)
     ********************************/
    let rankingLastVisible = null;
    let isRankingLoading = false;
    let rankingCount = 0;
    const RANKING_PAGE_SIZE = 10;
    async function loadMoreRanking() {
      if (isRankingLoading) return;
      isRankingLoading = true;
      let q = query(
        collection(db, 'users'),
        orderBy('score', 'desc'),
        limit(RANKING_PAGE_SIZE)
      );
      if (rankingLastVisible) {
        q = query(
          collection(db, 'users'),
          orderBy('score', 'desc'),
          startAfter(rankingLastVisible),
          limit(RANKING_PAGE_SIZE)
        );
      }
      const snapshot = await getDocs(q);
      const rankingContainer = document.getElementById('rankingContainer');
      if (!snapshot.empty) {
        snapshot.forEach(docSnap => {
          rankingCount++;
          const userData = docSnap.data();
          const rankInfo = getRankByScore(userData.score || 0);
          const item = document.createElement('div');
          item.className = 'p-2 border-bottom';
          item.innerHTML = `<strong>${rankingCount}위</strong> - ${userData.nickname || '익명'} : ${userData.score}점 ${rankInfo.icon}`;
          rankingContainer.appendChild(item);
          rankingLastVisible = docSnap;
        });
      }
      isRankingLoading = false;
    }
    const rankingModalEl = document.getElementById('rankingModal');
    rankingModalEl.addEventListener('show.bs.modal', () => {
      rankingLastVisible = null;
      rankingCount = 0;
      document.getElementById('rankingContainer').innerHTML = '';
      loadMoreRanking();
    });
    const rankingContainer = document.getElementById('rankingContainer');
    rankingContainer.addEventListener('scroll', () => {
      if (rankingContainer.scrollTop + rankingContainer.clientHeight >= rankingContainer.scrollHeight - 50) loadMoreRanking();
    });

    /********************************
     * 폭죽(Confetti) 애니메이션
     ********************************/
    function launchFireworks() {
      const duration = 2000;
      const animationEnd = Date.now() + duration;
      const defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 1000 };
      const interval = setInterval(() => {
        const timeLeft = animationEnd - Date.now();
        if (timeLeft <= 0) { clearInterval(interval); return; }
        const particleCount = 50 * (timeLeft / duration);
        confetti(Object.assign({}, defaults, {
          particleCount,
          origin: { x: Math.random(), y: Math.random() - 0.2 }
        }));
      }, 250);
    }
    async function highlightPostFromQuery() {
      const urlParams = new URLSearchParams(window.location.search);
      const highlightPostId = urlParams.get('postId');
      if (!highlightPostId) return;
      const existingCard = document.getElementById('postCard-' + highlightPostId);
      if (existingCard) {
        if (postList.firstChild !== existingCard) {
          postList.insertBefore(existingCard, postList.firstChild);
        }
        existingCard.style.border = '3px solid gold';
      } else {
        const postRef = doc(db, 'posts', highlightPostId);
        const postSnap = await getDoc(postRef);
        if (postSnap.exists()) {
          const card = await createPostItem(postSnap);
          card.style.border = '3px solid gold';
          postList.insertBefore(card, postList.firstChild);
          
          // → 추가: 실시간 업데이트를 위한 onSnapshot 리스너 등록 (게시글)
          onSnapshot(postRef, (updatedSnap) => {
            if (updatedSnap.exists()) updatePostUI(updatedSnap);
          });
          
          // → 추가: 댓글 리스너 등록 (댓글이 보이지 않는 버그 수정)
          if (!commentUnsubscribers[highlightPostId]) {
            const cmtQuery = query(
              collection(db, 'posts', highlightPostId, 'comments'),
              orderBy('createdAt', 'asc')
            );
            commentUnsubscribers[highlightPostId] = onSnapshot(cmtQuery, (cmtSnapshot) => {
              const cmtData = [];
              cmtSnapshot.forEach((cmtDoc) => {
                const cdata = cmtDoc.data();
                cdata.commentId = cmtDoc.id;
                cmtData.push(cdata);
              });
              const commentListEl = document.querySelector(`#commentList-${highlightPostId}`);
              if (commentListEl) renderComments(highlightPostId, cmtData, commentListEl);
            });
          }
        }
      }
    }

    deleteAccountBtn.addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) {
        showToast('로그인 상태가 아닙니다.', '오류');
        return;
      }
      if (!confirm('회원탈퇴 시, 작성하신 댓글은 삭제되지 않고 남습니다.\n댓글은 별도로 직접 삭제하셔야 하며,\n댓글을 제외한 모든 작성글과 계정이 완전히 삭제됩니다.\n정말로 탈퇴하시겠습니까?')) return;
      try {
        const postsQuery = query(collection(db, 'posts'), where('uid', '==', user.uid));
        const postsSnapshot = await getDocs(postsQuery);
        const deletePromises = postsSnapshot.docs.map(docSnap => deleteDoc(docSnap.ref));
        await Promise.all(deletePromises);
        await deleteDoc(doc(db, 'users', user.uid));
        await deleteUser(user);
        showToast('회원탈퇴가 완료되었습니다.', '회원탈퇴');
        await signOut(auth);
      } catch (err) {
        showToast(err.message, '회원탈퇴 실패');
      }
    });

    function launchFireworkSpread() {
      const duration = 500; // 효과 지속 시간 (ms)
      const animationEnd = Date.now() + duration;
      const defaults = {
        origin: { x: 0.5, y: 0.5 },
        colors: ['#ff595e', '#ffca3a', '#8ac926', '#1982c4', '#6a4c93'],
        startVelocity: 45,
        particleCount: 20,
        spread: 360,
        ticks: 60
      };
      (function frame() {
        const timeLeft = animationEnd - Date.now();
        if (timeLeft <= 0) return;
        confetti(Object.assign({}, defaults, {
          particleCount: 20,
          startVelocity: 30 + Math.random() * 20,
          angle: Math.random() * 360
        }));
        requestAnimationFrame(frame);
      }());
    }

    async function init() {
      fetchActiveNotices();    
      const response = await fetch('quiz.json');
      quizQuestionsAll = await response.json();

      await loadMorePosts();
      await highlightPostFromQuery();
    }

    init();
  </script>
</body>
</html>
